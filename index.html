<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qirra</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a more sophisticated look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --p1-color: #384259;
            --p2-color: #F73B8A;
            --board-bg: #1A1A2E;
            --cell-bg: #272C42;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0E0E1A;
            color: #E2E8F0;
            font-size: 1rem;
            letter-spacing: 0.5px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #game-title {
            font-family: 'Cinzel', serif;
            letter-spacing: 2px;
        }
        .board {
            display: grid;
            gap: 1px;
            background-color: var(--board-bg);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: opacity 0.5s;
        }
        .board.active {
            opacity: 1;
        }
        .board.inactive {
            opacity: 0.5;
            pointer-events: none;
        }
        .cell {
            position: relative;
            background-color: var(--cell-bg);
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
        }
        .cell:hover:not(.occupied) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .stone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            height: 85%;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            transition: all 0.2s ease-in-out;
        }
        .p1 {
            background: radial-gradient(circle at 30% 30%, #4D5773, #384259);
        }
        .p2 {
            background: radial-gradient(circle at 30% 30%, #FF6B9E, #F73B8A);
        }
        .turn-highlight {
            box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.5);
        }
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease-in-out;
            background: var(--cell-bg);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .scoreboard {
            min-width: 320px;
        }
        .score-box {
            background-color: var(--cell-bg);
            border-radius: 8px;
            padding: 10px 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        /* Modal Styles */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); z-index: 100;
            display: flex; justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: #1A1A2E; border-radius: 10px; padding: 20px 40px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.8);
            border: 2px solid #F73B8A; max-width: 450px; text-align: center;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Game Title -->
    <h1 id="game-title" class="text-6xl font-bold mb-4 md:mb-8 text-white">Qirra</h1>

    <!-- Player Info and Scoreboard -->
    <div class="scoreboard flex justify-around items-center w-full max-w-lg mb-4 md:mb-8 space-x-4">
        <div id="p1-info" class="score-box flex-1 text-center border-l-4 border-[var(--p1-color)]">
            <div class="text-sm font-bold opacity-70">Player 1 (You)</div>
            <div id="p1-score" class="text-3xl font-bold text-[var(--p1-color)]">0</div>
        </div>
        <div id="p2-info" class="score-box flex-1 text-center border-r-4 border-[var(--p2-color)]">
            <div class="text-sm font-bold opacity-70">Player 2 (Opponent)</div>
            <div id="p2-score" class="text-3xl font-bold text-[var(--p2-color)]">0</div>
        </div>
    </div>

    <!-- Game Status Display -->
    <div id="game-status" class="text-center font-bold text-lg h-10 mb-4 text-[#F73B8A]">Waiting for a match...</div>

    <!-- Game Board -->
    <div class="board inactive w-[90vmin] h-[90vmin] max-w-[500px] max-h-[500px]" id="board"></div>

    <!-- Game Controls -->
    <div class="flex items-center justify-center space-x-4 mt-8">
        <button class="btn bg-blue-500 hover:bg-blue-600 text-white" id="matchmaking-btn">Find Match</button>
        <button class="btn text-white disabled:opacity-50 disabled:cursor-not-allowed" id="pass-btn" disabled>Pass Turn</button>
    </div>

    <!-- Custom Modal for Alerts and Game End -->
    <div id="game-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="modal-title" class="text-2xl font-bold mb-4"></h3>
            <p id="modal-message" class="mb-6"></p>
            <button id="modal-close-btn" class="btn bg-[#F73B8A] text-white">OK</button>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getDatabase, ref, onValue, set, onDisconnect } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- DOM Elements ---
        const boardEl = document.getElementById('board');
        const p1InfoEl = document.getElementById('p1-info');
        const p2InfoEl = document.getElementById('p2-info');
        const p1ScoreEl = document.getElementById('p1-score');
        const p2ScoreEl = document.getElementById('p2-score');
        const passBtn = document.getElementById('pass-btn');
        const matchmakingBtn = document.getElementById('matchmaking-btn');
        const statusEl = document.getElementById('game-status');

        // --- Firebase Setup ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        let app, db, rtdb, auth;

        // Game state variables
        const BOARD_SIZE = 9; // Fixed board size as per user request
        let localState = {
            boardData: [],
            p1Score: 0,
            p2Score: 0,
            currentPlayerId: null,
            players: [],
            passCount: 0,
            previousStates: [],
        };
        let currentGameId = null;
        let unsubscribeGame = null;
        let unsubscribeWaiting = null;
        let myPlayerColor = null;

        // Custom Modal
        const gameModal = document.getElementById('game-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        function showModal(title, message, onClose = null) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            gameModal.classList.remove('hidden');
            if (onClose) {
                modalCloseBtn.onclick = () => {
                    gameModal.classList.add('hidden');
                    onClose();
                };
            } else {
                modalCloseBtn.onclick = () => gameModal.classList.add('hidden');
            }
        }

        // --- Core Game Logic ---
        async function initializeAppLogic() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    throw new Error('Missing Firebase configuration. Check the environment variables.');
                }
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                rtdb = getDatabase(app);
                auth = getAuth(app);

                // Use the provided custom auth token if available, otherwise sign in anonymously
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                
                console.log("Authenticated with UID:", auth.currentUser.uid);
                setupPresence(); // Set up online status tracking
                matchmakingBtn.disabled = false;
                statusEl.textContent = "Ready to find a match.";
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                statusEl.textContent = "Offline mode: No matchmaking available.";
                showModal("Connection Error", "The game could not connect to the database. Please try again later.", () => {});
            }
            setupUI();
        }

        function setupPresence() {
            if (!auth.currentUser) return;
            const myStatusRef = ref(rtdb, 'status/' + auth.currentUser.uid);
            onDisconnect(myStatusRef).remove();
            set(myStatusRef, true);

            const statusRef = ref(rtdb, 'status');
            onValue(statusRef, (snapshot) => {
                // The current app doesn't have an online counter, so we can just log it
                const count = snapshot.numChildren();
                console.log(`Players Online: ${count}`);
            });
        }

        function setupUI() {
            createBoard();
            matchmakingBtn.addEventListener('click', findMatch);
            passBtn.addEventListener('click', handlePass);
        }

        async function findMatch() {
            if (!auth || !db) {
                statusEl.textContent = "Matchmaking unavailable.";
                return;
            }
            if (unsubscribeWaiting) unsubscribeWaiting();
            matchmakingBtn.disabled = true;
            statusEl.textContent = "Searching for an opponent...";

            const waitingPoolRef = collection(db, `artifacts/${appId}/public/data/waiting_pool`);
            const q = query(waitingPoolRef); // Look for any player, not a specific code
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                // No one is waiting, so we create a waiting document
                const myWaitingRef = doc(db, `artifacts/${appId}/public/data/waiting_pool`, auth.currentUser.uid);
                await setDoc(myWaitingRef, { waitingSince: new Date(), boardSize: BOARD_SIZE });

                // Listen for our waiting doc to be deleted
                unsubscribeWaiting = onSnapshot(myWaitingRef, (doc) => {
                    if (!doc.exists()) {
                        statusEl.textContent = "Opponent found! Starting game...";
                        if(unsubscribeWaiting) unsubscribeWaiting();
                    }
                });
            } else {
                // Found a waiting player, let's start a game
                const opponentDoc = querySnapshot.docs[0];
                const opponentId = opponentDoc.id;
                
                // Use a transaction to ensure atomicity when deleting and creating a game
                await runTransaction(db, async (transaction) => {
                    transaction.delete(opponentDoc.ref);

                    const newGameId = `game_${auth.currentUser.uid}_${opponentId}_${Date.now()}`;
                    const players = [auth.currentUser.uid, opponentId];
                    const newGameData = {
                        players,
                        boardSize: BOARD_SIZE,
                        boardData: Array(BOARD_SIZE * BOARD_SIZE).fill(null),
                        p1Score: 0,
                        p2Score: 0,
                        currentPlayerId: players[0],
                        passCount: 0,
                        previousStates: [],
                        createdAt: new Date()
                    };

                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, newGameId);
                    transaction.set(gameRef, newGameData);
                    joinGame(newGameId);
                });
            }
        }
        
        function joinGame(gameId) {
            currentGameId = gameId;
            if (unsubscribeGame) unsubscribeGame();

            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            unsubscribeGame = onSnapshot(gameRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const gameData = docSnapshot.data();
                    updateLocalState(gameData);
                    renderGame();
                } else {
                    // Game was deleted (e.g., opponent left)
                    endGame("The opponent left the game.");
                }
            });
        }

        function updateLocalState(gameData) {
            localState = { ...localState, ...gameData };
            myPlayerColor = localState.players.indexOf(auth.currentUser.uid) === 0 ? 'p1' : 'p2';
        }

        function renderGame() {
            p1ScoreEl.textContent = localState.p1Score;
            p2ScoreEl.textContent = localState.p2Score;

            const myTurn = localState.currentPlayerId === auth.currentUser.uid;
            
            p1InfoEl.classList.toggle('turn-highlight', localState.players[0] === localState.currentPlayerId);
            p2InfoEl.classList.toggle('turn-highlight', localState.players[1] === localState.currentPlayerId);
            
            statusEl.textContent = myTurn ? "It's your turn." : "Opponent's turn...";
            boardEl.classList.remove('inactive');
            passBtn.disabled = !myTurn;
            matchmakingBtn.disabled = true;

            renderBoard();
        }

        function createBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
            boardEl.style.gridTemplateRows = `repeat(${BOARD_SIZE}, 1fr)`;
            const boardSizePx = Math.min(window.innerWidth, window.innerHeight) * 0.8;
            boardEl.style.width = `${boardSizePx}px`;
            boardEl.style.height = `${boardSizePx}px`;
            
            // Set cell size dynamically based on board size
            boardEl.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;

            for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                boardEl.appendChild(cell);
            }
        }

        function renderBoard() {
            const cells = Array.from(boardEl.children);
            for (let i = 0; i < localState.boardData.length; i++) {
                const cell = cells[i];
                cell.classList.toggle('occupied', localState.boardData[i] !== null);
                if (cell.firstChild) cell.removeChild(cell.firstChild);
                
                if (localState.boardData[i]) {
                    const stone = document.createElement('div');
                    const playerClass = localState.boardData[i];
                    stone.classList.add('stone', playerClass);
                    cell.appendChild(stone);
                }
            }
        }

        async function handleCellClick(e) {
            if (localState.currentPlayerId !== auth.currentUser.uid) return;
            const index = parseInt(e.currentTarget.dataset.index);
            if (localState.boardData[index]) return;

            const playerColor = localState.players.indexOf(auth.currentUser.uid) === 0 ? 'p1' : 'p2';
            const opponentColor = playerColor === 'p1' ? 'p2' : 'p1';
            
            let tempBoard = [...localState.boardData];
            tempBoard[index] = playerColor;
            
            const capturedStones = [];
            getNeighbors(index, BOARD_SIZE).forEach(n => {
                if (tempBoard[n] === opponentColor) {
                    const group = getGroup(n, tempBoard, BOARD_SIZE);
                    if (hasNoLiberties(group, tempBoard, BOARD_SIZE)) {
                        capturedStones.push(...group);
                    }
                }
            });

            // If we captured something, remove them from the temp board
            capturedStones.forEach(i => tempBoard[i] = null);
            
            // Check for suicide
            const ownGroup = getGroup(index, tempBoard, BOARD_SIZE);
            if (hasNoLiberties(ownGroup, tempBoard, BOARD_SIZE)) {
                showModal("Illegal Move", "This move is a suicide and is not allowed.");
                return;
            }

            // Check for Ko rule (if the new board state is identical to the previous one)
            const stateString = JSON.stringify(tempBoard);
            if (localState.previousStates.includes(stateString)) {
                showModal("Illegal Move", "This move is not allowed due to the Ko rule (repeating a previous board state).");
                return;
            }

            // --- Update Firestore with the new state ---
            const nextPlayerId = localState.players.find(p => p !== auth.currentUser.uid);
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            
            let newP1Score = localState.p1Score;
            let newP2Score = localState.p2Score;
            if (playerColor === 'p1') {
                newP1Score += capturedStones.length;
            } else {
                newP2Score += capturedStones.length;
            }
            
            await updateDoc(gameRef, {
                boardData: tempBoard,
                currentPlayerId: nextPlayerId,
                passCount: 0,
                p1Score: newP1Score,
                p2Score: newP2Score,
                previousStates: [...localState.previousStates, JSON.stringify(localState.boardData)]
            });
        }

        async function handlePass() {
            if (localState.currentPlayerId !== auth.currentUser.uid) return;
            
            const newPassCount = localState.passCount + 1;
            if (newPassCount >= 2) {
                endGame("Both players passed. The game is over.");
            } else {
                const nextPlayerId = localState.players.find(p => p !== auth.currentUser.uid);
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                await updateDoc(gameRef, {
                    currentPlayerId: nextPlayerId,
                    passCount: newPassCount
                });
            }
        }

        function endGame(message) {
            let winnerMessage = "";
            if (localState.p1Score > localState.p2Score) {
                winnerMessage = "Player 1 wins!";
            } else if (localState.p2Score > localState.p1Score) {
                winnerMessage = "Player 2 wins!";
            } else {
                winnerMessage = "It's a tie!";
            }
            showModal("Game Over", `${message}\nFinal Score: Player 1 - ${localState.p1Score}, Player 2 - ${localState.p2Score}\n${winnerMessage}`, () => {
                if (unsubscribeGame) unsubscribeGame();
                if (currentGameId) {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                    // deleteDoc(gameRef); // Optional: delete game after a delay
                }
                currentGameId = null;
                boardEl.classList.add('inactive');
                passBtn.disabled = true;
                matchmakingBtn.disabled = false;
                statusEl.textContent = "Ready to find a match.";
            });
        }

        // --- Helper Functions ---
        function getNeighbors(index, boardSize) {
            const neighbors = [];
            const x = index % boardSize;
            const y = Math.floor(index / boardSize);
            if (x > 0) neighbors.push(index - 1);
            if (x < boardSize - 1) neighbors.push(index + 1);
            if (y > 0) neighbors.push(index - boardSize);
            if (y < boardSize - 1) neighbors.push(index + boardSize);
            return neighbors;
        }

        function getGroup(startIndex, boardData, boardSize) {
            if (boardData[startIndex] === null) return [];
            const group = new Set(), queue = [startIndex], color = boardData[startIndex], visited = new Set([startIndex]);
            group.add(startIndex);
            while (queue.length > 0) {
                const currentIndex = queue.shift();
                getNeighbors(currentIndex, boardSize).forEach(neighborIndex => {
                    if (!visited.has(neighborIndex) && boardData[neighborIndex] === color) {
                        visited.add(neighborIndex);
                        group.add(neighborIndex);
                        queue.push(neighborIndex);
                    }
                });
            }
            return Array.from(group);
        }

        function hasNoLiberties(group, boardData, boardSize) {
            for (const stoneIndex of group) {
                if (getNeighbors(stoneIndex, boardSize).some(neighborIndex => boardData[neighborIndex] === null)) {
                    return false;
                }
            }
            return true;
        }
        
        // --- App Initialization ---
        initializeAppLogic();
    </script>
</body>
</html>
