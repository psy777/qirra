<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qirra</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Dongle:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --p1-color: #000000;
            --p1-glow-color: #ffffff;
            --p1-glow-size: 10px;
            --p2-color: #ffffff;
            --p2-glow-color: #00ffff;
            --p2-glow-size: 10px;
            --board-bg: #162447;
            --cell-bg: #1f4068;
            --cell-hover-bg: #1b3a5e;
        }
        body {
            font-family: 'Dongle', sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-size: 1.75rem;
            letter-spacing: 0.5px;
        }
        #game-title {
            font-family: 'Cinzel', serif;
        }
        .board {
            display: grid;
            gap: 1px;
            background-color: var(--board-bg);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            pointer-events: none; /* Disabled until a match starts */
            opacity: 0.5;
        }
        .board.active {
            pointer-events: auto;
            opacity: 1;
        }
        .cell {
            position: relative;
            background-color: var(--cell-bg);
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .cell:hover {
            background-color: var(--cell-hover-bg);
        }
        .stone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            border-radius: 50%;
            transition: border-radius 0.2s ease-in-out, background-color 0.3s, box-shadow 0.3s;
        }
        .black {
            background-color: var(--p1-color);
            box-shadow: 0 0 var(--p1-glow-size) var(--p1-glow-color);
        }
        .white {
            background-color: var(--p2-color);
            box-shadow: 0 0 var(--p2-glow-size) var(--p2-glow-color);
        }
        .controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .controls, .slider-control {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        .btn {
            background-color: var(--cell-bg);
            color: #e0e0e0;
            padding: 5px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
            margin: 0 10px;
            border: 2px solid transparent;
            font-size: 1.5rem;
        }
        .btn:hover {
            background-color: var(--cell-hover-bg);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .scoreboard {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
            width: 350px;
        }
        #game-status, #online-count-container {
            height: 2.5rem;
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 5px;
        }
        /* Modal Styles */
        .modal {
            position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.6);
        }
        .modal-content {
            background-color: #1a1a2e; margin: 10% auto; padding: 20px;
            border: 1px solid var(--p2-glow-color); border-radius: 10px;
            width: 80%; max-width: 500px; box-shadow: 0 0 20px var(--p2-glow-color);
            position: relative;
        }
        .close-btn {
            color: #aaa; position: absolute; top: 10px; right: 25px;
            font-size: 2.5rem; font-weight: bold; cursor: pointer;
        }
        .close-btn:hover, .close-btn:focus { color: white; }
        .settings-grid { display: grid; grid-template-columns: auto 1fr; gap: 15px; align-items: center; }
        .settings-grid h3 {
            grid-column: 1 / -1; font-family: 'Cinzel', serif; color: var(--p2-glow-color);
            border-bottom: 1px solid var(--p2-glow-color); padding-bottom: 5px;
        }
        input[type=range] { -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; width: 100%; }
        input[type=range]::-webkit-slider-runnable-track { height: 8px; background: var(--cell-bg); border-radius: 5px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%; background: var(--p2-glow-color); margin-top: -8px; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <h1 id="game-title" class="text-5xl font-bold mb-4">Qirra</h1>
    <div class="controls-container mb-4">
        <div class="slider-control">
            <label for="size-slider" class="mr-4">Size:</label>
            <input type="range" id="size-slider" min="5" max="25" value="8">
            <span id="size-label" class="ml-4 w-16 text-center">8x8</span>
        </div>
        <input id="match-code" type="text" placeholder="Match code (optional)" class="mt-2 p-2 rounded bg-[var(--cell-bg)] text-center" />
    </div>
    <div id="online-count-container">Players Online: <span id="online-count">0</span></div>
    <div id="game-status">Ready to play.</div>
    <div class="scoreboard">
        <div>Player 1: <span id="black-score">0</span></div>
        <div>Player 2: <span id="white-score">0</span></div>
    </div>
    <div class="board" id="board"></div>
    <div class="controls">
        <div class="btn" id="matchmaking-btn">Find Match</div>
        <div class="btn" id="offline-btn">Play Offline</div>
        <div class="btn" id="pass-btn" disabled>Pass</div>
        <div class="btn" id="settings-btn">Settings</div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal hidden">
        <div class="modal-content">
            <span id="close-modal" class="close-btn">&times;</span>
            <h2 class="text-3xl mb-4" style="font-family: 'Cinzel', serif;">Settings</h2>
            <div class="settings-grid">
                <h3>Player 1</h3>
                <label for="p1-color-picker">Tile Color</label> <input type="color" id="p1-color-picker" value="#000000">
                <label for="p1-glow-color-picker">Glow Color</label> <input type="color" id="p1-glow-color-picker" value="#ffffff">
                <label for="p1-glow-size-slider">Glow Size</label> <input type="range" id="p1-glow-size-slider" min="0" max="20" value="10">
                <h3>Player 2</h3>
                <label for="p2-color-picker">Tile Color</label> <input type="color" id="p2-color-picker" value="#ffffff">
                <label for="p2-glow-color-picker">Glow Color</label> <input type="color" id="p2-glow-color-picker" value="#00ffff">
                <label for="p2-glow-size-slider">Glow Size</label> <input type="range" id="p2-glow-size-slider" min="0" max="20" value="10">
                <h3>Board</h3>
                <label for="board-bg-picker">Board Color</label> <input type="color" id="board-bg-picker" value="#162447">
                <label for="cell-bg-picker">Cell Color</label> <input type="color" id="cell-bg-picker" value="#1f4068">
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getDatabase, ref, onValue, set, onDisconnect } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // DOM Elements
        const boardEl = document.getElementById('board');
        const p1ScoreEl = document.getElementById('black-score');
        const p2ScoreEl = document.getElementById('white-score');
        const passBtn = document.getElementById('pass-btn');
        const matchmakingBtn = document.getElementById('matchmaking-btn');
        const offlineBtn = document.getElementById('offline-btn');
        const sizeSlider = document.getElementById('size-slider');
        const sizeLabel = document.getElementById('size-label');
        const statusEl = document.getElementById('game-status');
        const onlineCountEl = document.getElementById('online-count');
        const matchCodeInput = document.getElementById('match-code');

        // --- Firebase Setup ---
        const appId = 'qirra-default';
        
        // Firebase configuration - Load from external sources
        let firebaseConfig = {};
        
        // Try to load configuration from multiple sources
        async function loadFirebaseConfig() {
            try {
                // Method 1: Try to import from external config file
                try {
                    const configModule = await import('./firebase-config.js');
                    firebaseConfig = configModule.firebaseConfig;
                    console.log('Loaded Firebase config from external file');
                } catch (importError) {
                    console.log('External config file not found, trying other methods...');
                }
                
                // Method 2: Check for environment variables (if available)
                if (typeof process !== 'undefined' && process.env) {
                    const envConfig = {
                        apiKey: process.env.FIREBASE_API_KEY,
                        authDomain: process.env.FIREBASE_AUTH_DOMAIN,
                        databaseURL: process.env.FIREBASE_DATABASE_URL,
                        projectId: process.env.FIREBASE_PROJECT_ID,
                        storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
                        messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
                        appId: process.env.FIREBASE_APP_ID
                    };
                    
                    // Only use env config if all required fields are present
                    if (envConfig.apiKey && envConfig.projectId) {
                        firebaseConfig = envConfig;
                        console.log('Loaded Firebase config from environment variables');
                    }
                }
                
                // Method 3: Check for global window variables (for runtime injection)
                if (typeof window !== 'undefined' && window.FIREBASE_CONFIG) {
                    firebaseConfig = window.FIREBASE_CONFIG;
                    console.log('Loaded Firebase config from window.FIREBASE_CONFIG');
                }
                
                // Method 4: Fallback to inline configuration (development only)
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "your-api-key-here") {
                    firebaseConfig = {
                        apiKey: "your-api-key-here",
                        authDomain: "your-project.firebaseapp.com",
                        databaseURL: "https://your-project-default-rtdb.firebaseio.com",
                        projectId: "your-project-id",
                        storageBucket: "your-project.appspot.com",
                        messagingSenderId: "123456789",
                        appId: "1:123456789:web:abcdef123456"
                    };
                    console.log('Using fallback Firebase config (development mode)');
                }
                
            } catch (error) {
                console.error('Error loading Firebase configuration:', error);
            }
        }

        let app, db, rtdb, auth, analytics;
        matchmakingBtn.disabled = true;

        // --- Game State ---
        let localState = {
            boardSize: 8,
            boardData: [],
            p1Score: 0,
            p2Score: 0,
            currentPlayerId: 'player1', // Start with player1 in offline mode
            players: ['player1', 'player2'], // Default offline players
            passCount: 0,
            previousStates: [],
            isOfflineMode: false,
            gameStarted: false
        };
        let currentGameId = null;
        let unsubscribeGame = null;
        let unsubscribeWaiting = null;

        // --- Core Game Logic ---
        async function initializeAppLogic() {
            // Load Firebase configuration from external sources
            await loadFirebaseConfig();
            
            try {
                // Check if Firebase config has real values (not placeholder)
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "your-api-key-here") {
                    throw new Error('Firebase configuration not set up. Please replace placeholder values with your actual Firebase project configuration.');
                }
                
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                rtdb = getDatabase(app);
                auth = getAuth(app);
                
                // Initialize Analytics (optional - only if supported)
                try {
                    analytics = getAnalytics(app);
                    console.log("Firebase Analytics initialized");
                } catch (analyticsError) {
                    console.log("Analytics not available:", analyticsError.message);
                }

                await signInAnonymously(auth);
                console.log("Authenticated with UID:", auth.currentUser.uid);
                setupPresence(); // Set up online status
                matchmakingBtn.disabled = false;
                statusEl.textContent = "Ready to play online!";
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                statusEl.textContent = "Offline mode only - Firebase not configured.";
                onlineCountEl.textContent = "N/A";
            }
            setupUI();
        }

        function setupPresence() {
            const myStatusRef = ref(rtdb, 'status/' + auth.currentUser.uid);
            onDisconnect(myStatusRef).remove();
            set(myStatusRef, { online: true });

            const statusRef = ref(rtdb, 'status');
            onValue(statusRef, (snapshot) => {
                onlineCountEl.textContent = snapshot.numChildren();
            });
        }

        function setupUI() {
            createBoard();
            matchmakingBtn.addEventListener('click', findMatch);
            offlineBtn.addEventListener('click', startOfflineGame);
            passBtn.addEventListener('click', handlePass);
            sizeSlider.addEventListener('input', e => sizeLabel.textContent = `${e.target.value}x${e.target.value}`);
            sizeSlider.addEventListener('change', e => {
                if (!currentGameId && !localState.gameStarted) { // Only allow size change if not in a game
                    localState.boardSize = parseInt(e.target.value);
                    createBoard();
                }
            });
        }

        async function findMatch() {
            if (!auth || !db) {
                statusEl.textContent = "Matchmaking unavailable.";
                return;
            }
            if (unsubscribeWaiting) unsubscribeWaiting();
            matchmakingBtn.disabled = true;
            statusEl.textContent = "Searching for an opponent...";

            const code = matchCodeInput.value.trim() || 'default'; // Use a default code if none provided
            const desiredBoardSize = localState.boardSize;
            const waitingPoolRef = collection(db, `artifacts/${appId}/public/data/waiting_pool`);
            
            // Query for an opponent with the same code and board size
            const q = query(waitingPoolRef, where('code', '==', code), where('boardSize', '==', desiredBoardSize), limit(1));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                // No one is waiting, so we wait
                statusEl.textContent = "Waiting for an opponent...";
                const myWaitingRef = doc(db, `artifacts/${appId}/public/data/waiting_pool`, auth.currentUser.uid);
                await setDoc(myWaitingRef, { 
                    waitingSince: new Date(), 
                    boardSize: desiredBoardSize, 
                    code: code 
                });

                // Listen for our waiting doc to be deleted, which means we've been matched
                unsubscribeWaiting = onSnapshot(myWaitingRef, (doc) => {
                    if (!doc.exists()) {
                        if(unsubscribeWaiting) unsubscribeWaiting();
                        // We don't start the game from here. The matcher starts it.
                        // We just need to listen for a new game invite.
                        listenForGameInvite();
                    }
                });

            } else {
                // Found a waiting player, let's start a game
                const opponentDoc = querySnapshot.docs[0];
                const opponentId = opponentDoc.id;

                // Delete opponent from waiting pool
                await deleteDoc(opponentDoc.ref);

                // Create a new game
                const newGameId = `game_${Math.random().toString(36).substr(2, 9)}`;
                const players = Math.random() < 0.5 ? [auth.currentUser.uid, opponentId] : [opponentId, auth.currentUser.uid]; // Randomize who goes first

                const newGameData = {
                    players,
                    boardSize: desiredBoardSize,
                    boardData: Array(desiredBoardSize * desiredBoardSize).fill(null),
                    p1Score: 0,
                    p2Score: 0,
                    currentPlayerId: players[0],
                    passCount: 0,
                    previousStates: [],
                    createdAt: new Date(),
                    gameId: newGameId
                };

                await setDoc(doc(db, `artifacts/${appId}/public/data/games`, newGameId), newGameData);
                // Both players will now get this game via their listeners
            }
            listenForGameInvite();
        }
        
        function listenForGameInvite() {
            if (unsubscribeGame) unsubscribeGame(); // Stop listening to old games
            
            const gamesRef = collection(db, `artifacts/${appId}/public/data/games`);
            const q = query(gamesRef, where('players', 'array-contains', auth.currentUser.uid));

            unsubscribeGame = onSnapshot(q, (snapshot) => {
                if (!snapshot.empty) {
                    // Assuming we join the newest game found
                    const gameDoc = snapshot.docs.sort((a,b) => b.data().createdAt.toMillis() - a.data().createdAt.toMillis())[0];
                    if (gameDoc.id !== currentGameId) {
                        joinGame(gameDoc.id);
                    } else {
                        // It's just an update to the current game
                         if (gameDoc.exists()) {
                            updateLocalState(gameDoc.data());
                            renderGame();
                        }
                    }
                }
            });
        }

        function joinGame(gameId) {
            if (unsubscribeWaiting) unsubscribeWaiting();
            currentGameId = gameId;
            statusEl.textContent = "Opponent found! Starting game...";
            
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            // The main listener in listenForGameInvite will handle updates
            onSnapshot(gameRef, (doc) => {
                 if (doc.exists()) {
                    updateLocalState(doc.data());
                    renderGame();
                } else {
                    endGame("Opponent left the game.");
                }
            })
        }

        function updateLocalState(gameData) {
            localState = { ...localState, ...gameData };
        }

        function renderGame() {
            if (localState.boardSize !== parseInt(boardEl.style.gridTemplateColumns.split('(')[1])) {
                createBoard();
            }
            renderBoard();
            p1ScoreEl.textContent = localState.p1Score;
            p2ScoreEl.textContent = localState.p2Score;

            const myTurn = localState.currentPlayerId === auth.currentUser.uid;
            const amIPlayer1 = localState.players[0] === auth.currentUser.uid;
            const myRole = amIPlayer1 ? 'Player 1 (Black)' : 'Player 2 (White)';

            statusEl.textContent = myTurn ? `Your turn, ${myRole}` : `Opponent's turn...`;
            boardEl.classList.add('active');
            passBtn.disabled = !myTurn;
            matchmakingBtn.textContent = 'Leave Game';
            matchmakingBtn.disabled = false;
            matchmakingBtn.onclick = leaveGame; // Change button function
            sizeSlider.disabled = true;
        }

        function createBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${localState.boardSize}, 1fr)`;
            boardEl.style.gridTemplateRows = `repeat(${localState.boardSize}, 1fr)`;
            const boardPixelWidth = Math.min(window.innerWidth, window.innerHeight) * 0.7;
            boardEl.style.width = `${boardPixelWidth}px`;
            boardEl.style.height = `${boardPixelWidth}px`;
            for (let i = 0; i < localState.boardSize * localState.boardSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                boardEl.appendChild(cell);
            }
        }

        function renderBoard() {
            Array.from(boardEl.children).forEach((cell, i) => {
                // Clear previous stone
                while (cell.firstChild) {
                    cell.removeChild(cell.firstChild);
                }
                // Add new stone if it exists in state
                if (localState.boardData[i]) {
                    const stone = document.createElement('div');
                    const playerClass = localState.boardData[i]; // 'black' or 'white'
                    stone.classList.add('stone', playerClass);
                    stone.style.borderRadius = getBorderRadiusForStone(i);
                    cell.appendChild(stone);
                }
            });
        }

        async function handleCellClick(e) {
            // Check if it's the current player's turn
            if (localState.isOfflineMode) {
                // In offline mode, allow any player to play
            } else {
                if (localState.currentPlayerId !== auth.currentUser.uid) return; // Not my turn in online mode
            }

            const index = parseInt(e.currentTarget.dataset.index);
            if (localState.boardData[index]) return; // Cell is not empty

            let playerColor;
            if (localState.isOfflineMode) {
                playerColor = localState.currentPlayerId === 'player1' ? 'black' : 'white';
            } else {
                playerColor = localState.players.indexOf(auth.currentUser.uid) === 0 ? 'black' : 'white';
            }
            
            // Create a temporary board to test the move
            let tempBoard = [...localState.boardData];
            tempBoard[index] = playerColor;
            
            const opponentColor = playerColor === 'black' ? 'white' : 'black';
            let capturedStones = 0;
            
            // 1. Check for captures of opponent stones
            getNeighbors(index, localState.boardSize).forEach(n => {
                if (tempBoard[n] === opponentColor) {
                    const group = getGroup(n, tempBoard, localState.boardSize);
                    if (hasNoLiberties(group, tempBoard, localState.boardSize)) {
                        capturedStones += group.length;
                        group.forEach(i => tempBoard[i] = null); // Remove captured stones
                    }
                }
            });

            // 2. Check for suicide
            const ownGroup = getGroup(index, tempBoard, localState.boardSize);
            if (hasNoLiberties(ownGroup, tempBoard, localState.boardSize)) {
                statusEl.textContent = "Suicide moves are not allowed.";
                setTimeout(() => { 
                    if (localState.isOfflineMode) {
                        renderOfflineGame();
                    } else {
                        renderGame();
                    }
                }, 2000);
                return;
            }

            // 3. Check for Ko rule (preventing repeating board state)
            const stateString = tempBoard.join('');
            if (localState.previousStates.includes(stateString)) {
                statusEl.textContent = "Move is not allowed due to the Ko rule.";
                setTimeout(() => { 
                    if (localState.isOfflineMode) {
                        renderOfflineGame();
                    } else {
                        renderGame();
                    }
                }, 2000);
                return;
            }

            // Update scores
            let newP1Score = localState.p1Score;
            let newP2Score = localState.p2Score;
            if (playerColor === 'black') newP1Score += capturedStones;
            else newP2Score += capturedStones;

            // Update local state
            localState.boardData = tempBoard;
            localState.p1Score = newP1Score;
            localState.p2Score = newP2Score;
            localState.passCount = 0; // Reset pass count on a valid move
            localState.previousStates = [...localState.previousStates.slice(-10), stateString]; // Keep last 10 states

            if (localState.isOfflineMode) {
                // Switch players in offline mode
                localState.currentPlayerId = localState.currentPlayerId === 'player1' ? 'player2' : 'player1';
                renderOfflineGame();
            } else {
                // Update Firestore for online mode
                const nextPlayerId = localState.players.find(p => p !== auth.currentUser.uid);
                localState.currentPlayerId = nextPlayerId;
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                
                await updateDoc(gameRef, {
                    boardData: tempBoard,
                    currentPlayerId: nextPlayerId,
                    passCount: 0,
                    p1Score: newP1Score,
                    p2Score: newP2Score,
                    previousStates: localState.previousStates
                });
            }
        }

        async function handlePass() {
            if (localState.isOfflineMode) {
                // In offline mode, allow pass
            } else {
                if (localState.currentPlayerId !== auth.currentUser.uid) return; // Not my turn in online mode
            }
            
            const newPassCount = localState.passCount + 1;
            localState.passCount = newPassCount;
            
            if (newPassCount >= 2) {
                // Game ends
                const winner = localState.p1Score > localState.p2Score ? "Player 1 Wins!" : 
                              localState.p2Score > localState.p1Score ? "Player 2 Wins!" : "It's a tie!";
                statusEl.textContent = `Game Over. ${winner}`;
                passBtn.disabled = true;
                
                if (!localState.isOfflineMode && unsubscribeGame) {
                    unsubscribeGame();
                }
            } else {
                if (localState.isOfflineMode) {
                    // Switch players in offline mode
                    localState.currentPlayerId = localState.currentPlayerId === 'player1' ? 'player2' : 'player1';
                    renderOfflineGame();
                } else {
                    // Update Firestore for online mode
                    const nextPlayerId = localState.players.find(p => p !== auth.currentUser.uid);
                    localState.currentPlayerId = nextPlayerId;
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                    await updateDoc(gameRef, {
                        currentPlayerId: nextPlayerId,
                        passCount: newPassCount
                    });
                }
            }
        }
        
        async function leaveGame() {
             if (currentGameId) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                await deleteDoc(gameRef); // This will notify the other player
            }
            resetToLobby();
        }

        function endGame(message) {
            statusEl.textContent = message;
            resetToLobby();
        }
        
        function startOfflineGame() {
            // Reset game state for offline mode
            localState = {
                boardSize: parseInt(sizeSlider.value),
                boardData: Array(parseInt(sizeSlider.value) * parseInt(sizeSlider.value)).fill(null),
                p1Score: 0,
                p2Score: 0,
                currentPlayerId: 'player1',
                players: ['player1', 'player2'],
                passCount: 0,
                previousStates: [],
                isOfflineMode: true,
                gameStarted: true
            };
            
            createBoard();
            renderOfflineGame();
            
            // Update UI for offline game
            matchmakingBtn.textContent = 'End Game';
            matchmakingBtn.onclick = endOfflineGame;
            offlineBtn.style.display = 'none';
            sizeSlider.disabled = true;
            statusEl.textContent = "Player 1's turn (Black)";
            boardEl.classList.add('active');
            passBtn.disabled = false;
        }

        function renderOfflineGame() {
            renderBoard();
            p1ScoreEl.textContent = localState.p1Score;
            p2ScoreEl.textContent = localState.p2Score;
            
            const currentPlayer = localState.currentPlayerId === 'player1' ? 'Player 1 (Black)' : 'Player 2 (White)';
            statusEl.textContent = `${currentPlayer}'s turn`;
            
            passBtn.disabled = false;
        }

        function endOfflineGame() {
            resetToLobby();
        }

        function resetToLobby() {
            if (unsubscribeGame) unsubscribeGame();
            unsubscribeGame = null;
            currentGameId = null;
            
            // Reset offline mode state
            localState.isOfflineMode = false;
            localState.gameStarted = false;
            
            boardEl.classList.remove('active');
            passBtn.disabled = true;
            matchmakingBtn.textContent = 'Find Match';
            matchmakingBtn.disabled = false;
            matchmakingBtn.onclick = findMatch;
            offlineBtn.style.display = 'inline-block';
            sizeSlider.disabled = false;
            statusEl.textContent = "Ready to play.";
            
            // Re-initialize board to default size
            localState.boardSize = parseInt(sizeSlider.value);
            localState.boardData = Array(localState.boardSize * localState.boardSize).fill(null);
            localState.p1Score = 0;
            localState.p2Score = 0;
            localState.passCount = 0;
            localState.previousStates = [];
            createBoard();
            renderBoard(); // Render the empty board
            p1ScoreEl.textContent = '0';
            p2ScoreEl.textContent = '0';
        }

        // --- Helper Functions (no changes needed) ---
        function getBorderRadiusForStone(index) {
            const color = localState.boardData[index];
            if (!color) return '50%';
            const { boardSize, boardData } = localState;
            const x = index % boardSize;
            const y = Math.floor(index / boardSize);
            const hasTopNeighbor = y > 0 && boardData[index - boardSize] === color;
            const hasRightNeighbor = x < boardSize - 1 && boardData[index + 1] === color;
            const hasBottomNeighbor = y < boardSize - 1 && boardData[index + boardSize] === color;
            const hasLeftNeighbor = x > 0 && boardData[index - 1] === color;
            const round = '50%', flat = '20%';
            const topLeft = (hasTopNeighbor || hasLeftNeighbor) ? flat : round;
            const topRight = (hasTopNeighbor || hasRightNeighbor) ? flat : round;
            const bottomRight = (hasBottomNeighbor || hasRightNeighbor) ? flat : round;
            const bottomLeft = (hasBottomNeighbor || hasLeftNeighbor) ? flat : round;
            return `${topLeft} ${topRight} ${bottomRight} ${bottomLeft}`;
        }
        function getNeighbors(index, boardSize) {
            const neighbors = [];
            const x = index % boardSize, y = Math.floor(index / boardSize);
            if (x > 0) neighbors.push(index - 1);
            if (x < boardSize - 1) neighbors.push(index + 1);
            if (y > 0) neighbors.push(index - boardSize);
            if (y < boardSize - 1) neighbors.push(index + boardSize);
            return neighbors;
        }
        function getGroup(startIndex, boardData, boardSize) {
            if (boardData[startIndex] === null) return [];
            const group = new Set([startIndex]), queue = [startIndex], color = boardData[startIndex], visited = new Set([startIndex]);
            while (queue.length > 0) {
                const currentIndex = queue.shift();
                getNeighbors(currentIndex, boardSize).forEach(neighborIndex => {
                    if (!visited.has(neighborIndex) && boardData[neighborIndex] === color) {
                        visited.add(neighborIndex);
                        group.add(neighborIndex);
                        queue.push(neighborIndex);
                    }
                });
            }
            return Array.from(group);
        }
        function hasNoLiberties(group, boardData, boardSize) {
            if (group.length === 0) return false;
            for (const stoneIndex of group) {
                if (getNeighbors(stoneIndex, boardSize).some(neighborIndex => boardData[neighborIndex] === null)) return false;
            }
            return true;
        }

        // --- Settings Modal (no changes needed) ---
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeModalBtn = document.getElementById('close-modal');
        settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
        closeModalBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
        window.addEventListener('click', e => { if (e.target == settingsModal) settingsModal.classList.add('hidden'); });
        const setCssVar = (name, value) => document.documentElement.style.setProperty(name, value);
        function darkenColor(hex, percent) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) hex = hex.split('').map(char => char + char).join('');
            const num = parseInt(hex, 16), amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt, G = (num >> 8 & 0x00FF) - amt, B = (num & 0x0000FF) - amt;
            return `#${(0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1)}`;
        }
        document.getElementById('p1-color-picker').addEventListener('input', e => setCssVar('--p1-color', e.target.value));
        document.getElementById('p1-glow-color-picker').addEventListener('input', e => setCssVar('--p1-glow-color', e.target.value));
        document.getElementById('p1-glow-size-slider').addEventListener('input', e => setCssVar('--p1-glow-size', e.target.value + 'px'));
        document.getElementById('p2-color-picker').addEventListener('input', e => setCssVar('--p2-color', e.target.value));
        document.getElementById('p2-glow-color-picker').addEventListener('input', e => setCssVar('--p2-glow-color', e.target.value));
        document.getElementById('p2-glow-size-slider').addEventListener('input', e => setCssVar('--p2-glow-size', e.target.value + 'px'));
        document.getElementById('board-bg-picker').addEventListener('input', e => setCssVar('--board-bg', e.target.value));
        document.getElementById('cell-bg-picker').addEventListener('input', e => {
            const newColor = e.target.value;
            setCssVar('--cell-bg', newColor);
            setCssVar('--cell-hover-bg', darkenColor(newColor, 10));
        });
        
        // --- App Initialization ---
        initializeAppLogic();

    </script>
</body>
</html>
