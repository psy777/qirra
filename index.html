<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qirra</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root {
            --primary-color: #1976d2;
            --primary-dark: #1565c0;
            --primary-light: #42a5f5;
            --secondary-color: #dc004e;
            --background: #fafafa;
            --surface: #ffffff;
            --surface-variant: #f5f5f5;
            --on-surface: #1c1b1f;
            --on-surface-variant: #49454f;
            --outline: #79747e;
            --shadow: rgba(0, 0, 0, 0.12);
            --elevation-1: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
            --elevation-2: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
            --elevation-3: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);
            --player1-color: #000000;
            --player2-color: #ffffff;
            --board-bg: #8d6e63;
            --cell-bg: #a1887f;
            --cell-hover: #bcaaa4;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background);
            color: var(--on-surface);
            line-height: 1.5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-bar {
            background-color: var(--primary-color);
            color: white;
            padding: 16px 24px;
            box-shadow: var(--elevation-2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .app-title {
            font-family: 'Cinzel', serif;
            font-size: 24px;
            font-weight: 700;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
            gap: 24px;
            width: 100%;
        }

        .card {
            background-color: var(--surface);
            border-radius: 12px;
            box-shadow: var(--elevation-1);
            padding: 24px;
        }

        .card-title {
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--on-surface);
        }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 24px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            min-height: 48px;
        }

        .btn:hover {
            background-color: var(--primary-dark);
            box-shadow: var(--elevation-2);
        }

        .btn:disabled {
            background-color: var(--outline);
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-outlined {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .btn-outlined:hover {
            background-color: rgba(25, 118, 210, 0.04);
        }

        .btn-text {
            background-color: transparent;
            color: var(--primary-color);
            box-shadow: none;
        }

        .btn-text:hover {
            background-color: rgba(25, 118, 210, 0.04);
        }

        .btn-danger {
            background-color: var(--secondary-color);
        }

        .btn-danger:hover {
            background-color: #b71c1c;
        }

        .text-field {
            width: 100%;
            padding: 16px;
            border: 1px solid var(--outline);
            border-radius: 4px;
            font-size: 16px;
            background-color: var(--surface);
            color: var(--on-surface);
            transition: border-color 0.2s ease;
        }

        .text-field:focus {
            outline: none;
            border-color: var(--primary-color);
            border-width: 2px;
        }

        .game-board {
            display: grid;
            gap: 2px;
            background-color: var(--board-bg);
            padding: 16px;
            border-radius: 12px;
            box-shadow: var(--elevation-2);
            margin: 0 auto;
            max-width: min(80vw, 80vh);
            aspect-ratio: 1;
        }

        .cell {
            background-color: var(--cell-bg);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            position: relative;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell:hover {
            background-color: var(--cell-hover);
        }

        .stone {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            transition: all 0.2s ease;
            box-shadow: var(--elevation-1);
        }

        .stone.black {
            background-color: var(--player1-color);
            border: 2px solid #333;
        }

        .stone.white {
            background-color: var(--player2-color);
            border: 2px solid #ddd;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-radius: 8px;
            background-color: var(--surface-variant);
            margin-bottom: 16px;
        }

        .player-info.active {
            background-color: var(--primary-light);
            color: white;
            box-shadow: var(--elevation-2);
        }

        .player-card {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
        }

        .player-avatar.black {
            background-color: var(--player1-color);
            color: white;
        }

        .player-avatar.white {
            background-color: var(--player2-color);
            color: black;
            border: 2px solid #ddd;
        }

        .match-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
        }

        .match-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border: 1px solid var(--outline);
            border-radius: 8px;
            background-color: var(--surface);
            transition: all 0.2s ease;
        }

        .match-item:hover {
            background-color: var(--surface-variant);
            cursor: pointer;
        }

        .match-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .match-title {
            font-weight: 500;
        }

        .match-details {
            font-size: 14px;
            color: var(--on-surface-variant);
        }

        .status-chip {
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
        }

        .status-waiting {
            background-color: #fff3e0;
            color: #e65100;
        }

        .status-playing {
            background-color: #e8f5e8;
            color: #2e7d32;
        }

        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .fab {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: var(--elevation-3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s ease;
        }

        .fab:hover {
            background-color: var(--primary-dark);
            transform: scale(1.1);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--surface);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--elevation-3);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--on-surface);
        }

        .hidden {
            display: none !important;
        }

        .game-container {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 24px;
            align-items: start;
        }

        .game-info {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .recent-games {
            max-height: 300px;
            overflow-y: auto;
        }

        .recent-game-item {
            padding: 12px;
            border-bottom: 1px solid var(--outline);
            font-size: 14px;
        }

        .recent-game-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 16px;
                gap: 16px;
            }

            .game-container {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .controls {
                justify-content: stretch;
            }

            .btn {
                flex: 1;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="app-bar">
        <div class="app-title">Qirra</div>
        <div id="online-status">
            <span class="material-icons">wifi_off</span>
            <span id="online-count">Offline</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Lobby View -->
        <div id="lobby-view">
            <div class="card">
                <div class="card-title">Join a Match</div>
                <div class="form-group">
                    <label class="form-label" for="player-name">Your Name</label>
                    <input type="text" id="player-name" class="text-field" placeholder="Enter your name" maxlength="20">
                </div>
                <div class="controls">
                    <button id="find-match-btn" class="btn">
                        <span class="material-icons">search</span>
                        Find Match
                    </button>
                    <button id="offline-btn" class="btn btn-outlined">
                        <span class="material-icons">person</span>
                        Play Offline
                    </button>
                </div>
            </div>

            <div class="card">
                <div class="card-title">Available Matches</div>
                <div id="match-list" class="match-list">
                    <div style="text-align: center; color: var(--on-surface-variant); padding: 24px;">
                        No matches available. Click "Find Match" to create one!
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-title">Recent Games</div>
                <div id="recent-games" class="recent-games">
                    <div style="text-align: center; color: var(--on-surface-variant); padding: 24px;">
                        No recent games yet.
                    </div>
                </div>
            </div>
        </div>

        <!-- Game View -->
        <div id="game-view" class="hidden">
            <div class="game-container">
                <div class="game-info">
                    <div class="card">
                        <div class="card-title">Game Info</div>
                        <div id="game-status">Waiting for players...</div>
                        <div id="match-code-display">
                            <strong>Match Code:</strong> <span id="current-match-code"></span>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div id="player-info" class="hidden">
                        <div id="player1-info" class="player-info">
                            <div class="player-card">
                                <div class="player-avatar black">●</div>
                                <div>
                                    <div id="player1-name">Player 1</div>
                                    <div style="font-size: 14px; color: var(--on-surface-variant);">Black stones</div>
                                </div>
                            </div>
                        </div>

                        <div id="player2-info" class="player-info">
                            <div class="player-card">
                                <div class="player-avatar white">●</div>
                                <div>
                                    <div id="player2-name">Player 2</div>
                                    <div style="font-size: 14px; color: var(--on-surface-variant);">White stones</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="game-board" class="game-board"></div>

                    <div class="controls">
                        <button id="pass-btn" class="btn btn-outlined" disabled>
                            <span class="material-icons">skip_next</span>
                            Pass
                        </button>
                        <button id="resign-btn" class="btn btn-danger hidden" disabled>
                            <span class="material-icons">flag</span>
                            Resign
                        </button>
                        <button id="leave-game-btn" class="btn btn-text">
                            <span class="material-icons">exit_to_app</span>
                            Leave Game
                        </button>
                    </div>
                </div>

                <div class="game-info">
                    <div class="card">
                        <div class="card-title">Settings</div>
                        <div class="form-group">
                            <label class="form-label" for="board-size">Board Size</label>
                            <select id="board-size" class="text-field">
                                <option value="9">9x9</option>
                                <option value="13">13x13</option>
                                <option value="19" selected>19x19</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, orderBy, limit, getDocs, serverTimestamp, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getDatabase, ref, onValue, set, onDisconnect, remove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // App Configuration
        const appId = 'qirra-default';
        
        // Firebase configuration - Load from external sources
        let firebaseConfig = {};
        
        async function loadFirebaseConfig() {
            try {
                try {
                    const configModule = await import('./firebase-config.js');
                    firebaseConfig = configModule.firebaseConfig;
                    console.log('Loaded Firebase config from external file');
                } catch (importError) {
                    console.log('External config file not found, using fallback...');
                }
                
                if (typeof window !== 'undefined' && window.FIREBASE_CONFIG) {
                    firebaseConfig = window.FIREBASE_CONFIG;
                    console.log('Loaded Firebase config from window.FIREBASE_CONFIG');
                }
                
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "your-api-key-here") {
                    firebaseConfig = {
                        apiKey: "your-api-key-here",
                        authDomain: "your-project.firebaseapp.com",
                        databaseURL: "https://your-project-default-rtdb.firebaseio.com",
                        projectId: "your-project-id",
                        storageBucket: "your-project.appspot.com",
                        messagingSenderId: "123456789",
                        appId: "1:123456789:web:abcdef123456"
                    };
                    console.log('Using fallback Firebase config (development mode)');
                }
                
            } catch (error) {
                console.error('Error loading Firebase configuration:', error);
            }
        }

        // Global variables
        let app, db, rtdb, auth;
        let currentMatchId = null;
        let currentGameState = null;
        let isOfflineMode = false;
        let playerRole = null; // 'player1', 'player2', or 'spectator'
        let unsubscribeMatch = null;
        let unsubscribeMatches = null;
        let unsubscribeWaitingPool = null;
        let playerTimeouts = new Map();
        let playerTimeoutInterval = 30000; // 30 seconds
        let sessionId = null; // Unique session ID for this player

        // DOM Elements
        const lobbyView = document.getElementById('lobby-view');
        const gameView = document.getElementById('game-view');
        const playerNameInput = document.getElementById('player-name');
        const findMatchBtn = document.getElementById('find-match-btn');
        const offlineBtn = document.getElementById('offline-btn');
        const matchList = document.getElementById('match-list');
        const recentGames = document.getElementById('recent-games');
        const gameBoard = document.getElementById('game-board');
        const gameStatus = document.getElementById('game-status');
        const playerInfo = document.getElementById('player-info');
        const player1Info = document.getElementById('player1-info');
        const player2Info = document.getElementById('player2-info');
        const player1Name = document.getElementById('player1-name');
        const player2Name = document.getElementById('player2-name');
        const passBtn = document.getElementById('pass-btn');
        const resignBtn = document.getElementById('resign-btn');
        const leaveGameBtn = document.getElementById('leave-game-btn');
        const boardSizeSelect = document.getElementById('board-size');
        const onlineStatus = document.getElementById('online-status');
        const onlineCount = document.getElementById('online-count');
        const matchCodeDisplay = document.getElementById('match-code-display');
        const currentMatchCode = document.getElementById('current-match-code');

        // Generate unique session ID
        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Generate 6-letter match code
        function generateMatchCode() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += letters.charAt(Math.floor(Math.random() * letters.length));
            }
            return result;
        }

        // Initialize the application
        async function initApp() {
            sessionId = generateSessionId();
            console.log('Session ID:', sessionId);
            
            await loadFirebaseConfig();
            
            try {
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "your-api-key-here") {
                    throw new Error('Firebase configuration not set up');
                }
                
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                rtdb = getDatabase(app);
                auth = getAuth(app);
                
                await signInAnonymously(auth);
                console.log("Authenticated with UID:", auth.currentUser.uid);
                
                setupPresence();
                setupEventListeners();
                loadAvailableMatches();
                loadRecentGames();
                
                onlineStatus.innerHTML = '<span class="material-icons">wifi</span>';
                onlineCount.textContent = 'Online';
                
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                onlineStatus.innerHTML = '<span class="material-icons">wifi_off</span>';
                onlineCount.textContent = 'Offline Only';
                setupEventListeners();
            }
        }

        function setupPresence() {
            const presenceRef = ref(rtdb, 'status/' + auth.currentUser.uid);
            onDisconnect(presenceRef).remove();
            
            const updatePresence = () => {
                set(presenceRef, {
                    online: true,
                    lastSeen: serverTimestamp(),
                    playerName: playerNameInput.value.trim() || 'Anonymous',
                    sessionId: sessionId
                });
            };
            
            updatePresence();
            setInterval(updatePresence, playerTimeoutInterval);

            const statusRef = ref(rtdb, 'status');
            onValue(statusRef, (snapshot) => {
                const count = snapshot.numChildren();
                onlineCount.textContent = count > 0 ? `${count} online` : 'Online';
            });

            window.addEventListener('beforeunload', handlePageUnload);
        }

        function setupEventListeners() {
            findMatchBtn.addEventListener('click', findMatch);
            offlineBtn.addEventListener('click', startOfflineGame);
            passBtn.addEventListener('click', handlePass);
            resignBtn.addEventListener('click', handleResign);
            leaveGameBtn.addEventListener('click', leaveCurrentMatch);

            // Update presence when name changes
            playerNameInput.addEventListener('input', () => {
                if (auth && auth.currentUser) {
                    const presenceRef = ref(rtdb, 'status/' + auth.currentUser.uid);
                    set(presenceRef, { 
                        online: true, 
                        lastSeen: serverTimestamp(),
                        playerName: playerNameInput.value.trim() || 'Anonymous',
                        sessionId: sessionId
                    });
                }
            });
        }

        async function findMatch() {
            const playerName = playerNameInput.value.trim() || 'Anonymous';
            
            if (!auth || !db) {
                alert('Online features not available');
                return;
            }

            try {
                // Check if there's anyone in the waiting pool
                const waitingPoolRef = collection(db, `artifacts/${appId}/waiting_pool`);
                const waitingQuery = query(waitingPoolRef, orderBy('createdAt', 'asc'), limit(1));
                const waitingSnapshot = await getDocs(waitingQuery);

                if (!waitingSnapshot.empty) {
                    // Join existing waiting player
                    const waitingDoc = waitingSnapshot.docs[0];
                    const waitingData = waitingDoc.data();
                    
                    // Create match with both players
                    const matchCode = waitingData.matchCode;
                    const boardSize = waitingData.boardSize;
                    
                    const matchData = {
                        matchCode: matchCode,
                        boardSize: boardSize,
                        createdAt: serverTimestamp(),
                        players: [waitingData.playerId, auth.currentUser.uid],
                        playerNames: {
                            [waitingData.playerId]: waitingData.playerName,
                            [auth.currentUser.uid]: playerName
                        },
                        playerSessions: {
                            [waitingData.playerId]: waitingData.sessionId,
                            [auth.currentUser.uid]: sessionId
                        },
                        status: 'playing',
                        gameState: {
                            boardData: Array(boardSize * boardSize).fill(null),
                            currentPlayer: 0, // 0 for player1, 1 for player2
                            passCount: 0,
                            gameHistory: []
                        },
                        lastActivity: serverTimestamp()
                    };

                    const matchRef = await addDoc(collection(db, `artifacts/${appId}/matches`), matchData);
                    
                    // Remove from waiting pool
                    await deleteDoc(waitingDoc.ref);
                    
                    // Join the match
                    currentMatchId = matchRef.id;
                    playerRole = 'player2';
                    startMatchListener(matchRef.id);
                    showGameView();
                    
                } else {
                    // No one waiting, create new waiting pool entry
                    const matchCode = generateMatchCode();
                    const boardSize = parseInt(boardSizeSelect.value);
                    
                    const waitingData = {
                        matchCode: matchCode,
                        playerId: auth.currentUser.uid,
                        playerName: playerName,
                        sessionId: sessionId,
                        boardSize: boardSize,
                        createdAt: serverTimestamp()
                    };

                    await addDoc(waitingPoolRef, waitingData);
                    
                    // Show waiting status
                    currentMatchCode.textContent = matchCode;
                    gameStatus.textContent = 'Waiting for opponent...';
                    showGameView();
                    
                    // Listen for when someone joins
                    startWaitingPoolListener();
                }

            } catch (error) {
                console.error('Error finding match:', error);
                alert('Failed to find match. Please try again.');
            }
        }

        function startWaitingPoolListener() {
            const matchesRef = collection(db, `artifacts/${appId}/matches`);
            const matchQuery = query(matchesRef, where('players', 'array-contains', auth.currentUser.uid));
            
            unsubscribeMatches = onSnapshot(matchQuery, (snapshot) => {
                snapshot.forEach((doc) => {
                    const matchData = doc.data();
                    if (matchData.players.length === 2) {
                        // Match found!
                        currentMatchId = doc.id;
                        playerRole = 'player1';
                        currentGameState = matchData;
                        
                        // Stop listening to waiting pool
                        if (unsubscribeMatches) unsubscribeMatches();
                        
                        // Start listening to match updates
                        startMatchListener(doc.id);
                        updateGameView(matchData);
                    }
                });
            });
        }

        async function loadAvailableMatches() {
            if (!db) return;

            if (unsubscribeMatches) unsubscribeMatches();

            const matchesRef = collection(db, `artifacts/${appId}/matches`);
            const q = query(
                matchesRef, 
                where('status', 'in', ['waiting', 'playing']),
                orderBy('createdAt', 'desc'),
                limit(20)
            );

            unsubscribeMatches = onSnapshot(q, (snapshot) => {
                const matches = [];
                snapshot.forEach((doc) => {
                    matches.push({ id: doc.id, ...doc.data() });
                });
                renderMatchList(matches);
            });
        }

        function renderMatchList(matches) {
            if (matches.length === 0) {
                matchList.innerHTML = `
                    <div style="text-align: center; color: var(--on-surface-variant); padding: 24px;">
                        No matches available. Click "Find Match" to create one!
                    </div>
                `;
                return;
            }

            matchList.innerHTML = matches.map(match => `
                <div class="match-item" onclick="spectateMatch('${match.id}')">
                    <div class="match-info">
                        <div class="match-title">Match ${match.matchCode}</div>
                        <div class="match-details">
                            ${match.boardSize}x${match.boardSize} • 
                            ${match.players.length}/2 players • 
                            ${match.playerNames[match.players[0]] || 'Player 1'} vs ${match.playerNames[match.players[1]] || 'Player 2'}
                        </div>
                    </div>
                    <div class="status-chip status-${match.status}">
                        ${match.status}
                    </div>
                </div>
            `).join('');
        }

        async function spectateMatch(matchId) {
            if (unsubscribeMatch) unsubscribeMatch();
            if (!auth || !db) {
                alert('Online features not available');
                return;
            }

            try {
                const matchRef = doc(db, `artifacts/${appId}/matches`, matchId);
                const matchDoc = await getDoc(matchRef);
                
                if (!matchDoc.exists()) {
                    alert('Match not found');
                    return;
                }

                const matchData = matchDoc.data();
                currentMatchId = matchId;
                playerRole = 'spectator';
                
                // Start listening to match updates
                startMatchListener(matchId);
                showGameView();

            } catch (error) {
                console.error('Error spectating match:', error);
                alert('Failed to spectate match. Please try again.');
            }
        }

        function startMatchListener(matchId) {
            if (unsubscribeMatch) unsubscribeMatch();

            const matchRef = doc(db, `artifacts/${appId}/matches`, matchId);
            unsubscribeMatch = onSnapshot(matchRef, (doc) => {
                if (doc.exists()) {
                    const matchData = doc.data();
                    currentGameState = matchData;
                    updateGameView(matchData);
                    
                    // Handle player timeouts
                    handlePlayerTimeouts(matchData);
                } else {
                    // Match was deleted
                    alert('Match has ended');
                    returnToLobby();
                }
            });
        }

        function handlePlayerTimeouts(matchData) {
            // Clear existing timeouts
            playerTimeouts.forEach(timeout => clearTimeout(timeout));
            playerTimeouts.clear();

            // Check for inactive players (30 second timeout)
            const now = Date.now();
            matchData.players.forEach((playerId, index) => {
                if (matchData.lastActivity && matchData.lastActivity.toMillis) {
                    const lastActivity = matchData.lastActivity.toMillis();
                    const timeSinceActivity = now - lastActivity;
                    
                    if (timeSinceActivity > 30000 && matchData.status === 'playing') {
                        // Player has been inactive for more than 30 seconds
                        const timeout = setTimeout(() => {
                            endMatchDueToTimeout(playerId);
                        }, 1000);
                        playerTimeouts.set(playerId, timeout);
                    }
                }
            });
        }

        async function endMatchDueToTimeout(inactivePlayerId) {
            if (!currentMatchId || !currentGameState) return;

            try {
                const matchRef = doc(db, `artifacts/${appId}/matches`, currentMatchId);
                const activePlayer = currentGameState.players.find(p => p !== inactivePlayerId);
                
                // Move to recent games
                await moveToRecentGames(currentGameState, activePlayer, 'timeout');
                
                // Delete the match
                await deleteDoc(matchRef);
                
                alert('Match ended due to player inactivity');
                returnToLobby();
                
            } catch (error) {
                console.error('Error ending match due to timeout:', error);
            }
        }

        async function moveToRecentGames(matchData, winnerId, endReason) {
            if (!db) return;

            try {
                const recentGameData = {
                    matchCode: matchData.matchCode,
                    boardSize: matchData.boardSize,
                    winner: matchData.playerNames[winnerId] || 'Unknown',
                    loser: matchData.playerNames[matchData.players.find(p => p !== winnerId)] || 'Unknown',
                    endReason: endReason,
                    endedAt: serverTimestamp()
                };

                await addDoc(collection(db, `artifacts/${appId}/recent_games`), recentGameData);
                
                // Clean up old recent games (keep only last 50)
                const recentGamesRef = collection(db, `artifacts/${appId}/recent_games`);
                const oldGamesQuery = query(recentGamesRef, orderBy('endedAt', 'desc'), limit(100));
                const oldGames = await getDocs(oldGamesQuery);
                
                if (oldGames.docs.length > 50) {
                    const gamesToDelete = oldGames.docs.slice(50);
                    for (const gameDoc of gamesToDelete) {
                        await deleteDoc(gameDoc.ref);
                    }
                }
                
            } catch (error) {
                console.error('Error moving game to recent games:', error);
            }
        }

        async function loadRecentGames() {
            if (!db) return;

            try {
                const recentGamesRef = collection(db, `artifacts/${appId}/recent_games`);
                const q = query(recentGamesRef, orderBy('endedAt', 'desc'), limit(10));
                const snapshot = await getDocs(q);
                
                const games = [];
                snapshot.forEach((doc) => {
                    games.push(doc.data());
                });
                
                renderRecentGames(games);
            } catch (error) {
                console.error('Error loading recent games:', error);
            }
        }

        function renderRecentGames(games) {
            if (games.length === 0) {
                recentGames.innerHTML = `
                    <div style="text-align: center; color: var(--on-surface-variant); padding: 24px;">
                        No recent games yet.
                    </div>
                `;
                return;
            }

            recentGames.innerHTML = games.map(game => `
                <div class="recent-game-item">
                    <div><strong>${game.winner || 'Draw'}</strong> vs ${game.loser || 'Unknown'}</div>
                    <div style="color: var(--on-surface-variant); font-size: 12px;">
                        Match ${game.matchCode} • ${game.boardSize}x${game.boardSize} • ${formatDate(game.endedAt)}
                    </div>
                </div>
            `).join('');
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }

        function showGameView() {
            lobbyView.classList.add('hidden');
            gameView.classList.remove('hidden');
        }

        function returnToLobby() {
            gameView.classList.add('hidden');
            lobbyView.classList.remove('hidden');
            
            // Clean up
            if (unsubscribeMatch) unsubscribeMatch();
            if (unsubscribeMatches) unsubscribeMatches();
            currentMatchId = null;
            currentGameState = null;
            playerRole = null;
            isOfflineMode = false;
            
            // Clear timeouts
            playerTimeouts.forEach(timeout => clearTimeout(timeout));
            playerTimeouts.clear();
            
            // Reload match list
            loadAvailableMatches();
            loadRecentGames();
        }

        function updateGameView(matchData) {
            // Show match code
            currentMatchCode.textContent = matchData.matchCode;
            
            // Update game status
            if (matchData.status === 'waiting') {
                gameStatus.textContent = 'Waiting for second player...';
                playerInfo.classList.add('hidden');
                passBtn.disabled = true;
                resignBtn.classList.add('hidden');
            } else if (matchData.status === 'playing') {
                const currentPlayerName = matchData.playerNames[matchData.players[matchData.gameState.currentPlayer]];
                gameStatus.textContent = `${currentPlayerName}'s turn`;
                playerInfo.classList.remove('hidden');
                
                // Enable/disable controls based on role and turn
                if (playerRole === 'spectator') {
                    passBtn.disabled = true;
                    resignBtn.classList.add('hidden');
                } else {
                    const isMyTurn = matchData.players[matchData.gameState.currentPlayer] === auth.currentUser.uid;
                    passBtn.disabled = !isMyTurn;
                    resignBtn.classList.remove('hidden');
                    resignBtn.disabled = false;
                }
            }

            // Update player info
            if (matchData.players.length >= 2) {
                player1Name.textContent = matchData.playerNames[matchData.players[0]] || 'Player 1';
                player2Name.textContent = matchData.playerNames[matchData.players[1]] || 'Player 2';
                
                // Highlight current player
                player1Info.classList.remove('active');
                player2Info.classList.remove('active');
                
                if (matchData.gameState.currentPlayer === 0) {
                    player1Info.classList.add('active');
                } else {
                    player2Info.classList.add('active');
                }
            }

            // Update board
            updateBoard(matchData.gameState);
        }

        function updateBoard(gameState) {
            const boardSize = Math.sqrt(gameState.boardData.length);
            
            // Create board if it doesn't exist or size changed
            if (gameBoard.children.length !== gameState.boardData.length) {
                createBoard(boardSize);
            }

            // Update cells
            Array.from(gameBoard.children).forEach((cell, i) => {
                // Clear previous stone
                while (cell.firstChild) {
                    cell.removeChild(cell.firstChild);
                }
                // Add new stone if it exists in state
                if (gameState.boardData[i] !== null) {
                    const stone = document.createElement('div');
                    const playerClass = gameState.boardData[i] === 0 ? 'black' : 'white';
                    stone.classList.add('stone', playerClass);
                    cell.appendChild(stone);
                }
            });
        }

        function createBoard(size) {
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${size}, 1fr)`;

            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.addEventListener('click', () => handleCellClick(i));
                gameBoard.appendChild(cell);
            }
        }

        async function handleCellClick(cellIndex) {
            if (!currentGameState || playerRole === 'spectator') return;
            if (currentGameState.status !== 'playing') return;
            
            // Check if it's the player's turn
            const currentPlayerIndex = currentGameState.gameState.currentPlayer;
            let myPlayerIndex;
            
            if (isOfflineMode) {
                // In offline mode, allow alternating turns
                myPlayerIndex = currentPlayerIndex;
            } else {
                myPlayerIndex = currentGameState.players.indexOf(auth.currentUser.uid);
                if (currentPlayerIndex !== myPlayerIndex) return;
            }
            
            if (currentGameState.gameState.boardData[cellIndex] !== null) return;

            try {
                // Make the move
                const newBoardData = [...currentGameState.gameState.boardData];
                newBoardData[cellIndex] = myPlayerIndex; // 0 for player1 (black), 1 for player2 (white)
                
                // Calculate captures
                const boardSize = Math.sqrt(newBoardData.length);
                const captured = calculateCaptures(newBoardData, cellIndex, boardSize);
                
                // Remove captured stones
                captured.forEach(capturedIndex => {
                    newBoardData[capturedIndex] = null;
                });

                // Check for suicide (not allowed)
                if (isSuicideMove(newBoardData, cellIndex, boardSize)) {
                    alert('Suicide moves are not allowed');
                    return;
                }

                // Update game state
                const newGameState = {
                    ...currentGameState.gameState,
                    boardData: newBoardData,
                    currentPlayer: 1 - currentPlayerIndex, // Switch players
                    passCount: 0, // Reset pass count
                    gameHistory: [...currentGameState.gameState.gameHistory, {
                        move: cellIndex,
                        player: myPlayerIndex,
                        captured: captured
                    }]
                };

                if (isOfflineMode) {
                    // Update local state directly
                    currentGameState.gameState = newGameState;
                    updateGameView(currentGameState);
                } else {
                    // Update Firestore
                    const matchRef = doc(db, `artifacts/${appId}/matches`, currentMatchId);
                    await updateDoc(matchRef, {
                        gameState: newGameState,
                        lastActivity: serverTimestamp()
                    });
                }

            } catch (error) {
                console.error('Error making move:', error);
                alert('Failed to make move. Please try again.');
            }
        }

        function calculateCaptures(boardData, moveIndex, boardSize) {
            const captured = [];
            const movePlayer = boardData[moveIndex];
            const opponentPlayer = 1 - movePlayer;
            
            // Check all adjacent cells
            const neighbors = getNeighbors(moveIndex, boardSize);
            
            neighbors.forEach(neighborIndex => {
                if (boardData[neighborIndex] === opponentPlayer) {
                    // Check if this opponent group has no liberties
                    const group = getGroup(neighborIndex, boardData, boardSize);
                    if (hasNoLiberties(group, boardData, boardSize)) {
                        captured.push(...group);
                    }
                }
            });
            
            return captured;
        }

        function isSuicideMove(boardData, moveIndex, boardSize) {
            const movePlayer = boardData[moveIndex];
            const group = getGroup(moveIndex, boardData, boardSize);
            return hasNoLiberties(group, boardData, boardSize);
        }

        function getNeighbors(index, boardSize) {
            const neighbors = [];
            const x = index % boardSize;
            const y = Math.floor(index / boardSize);
            
            if (x > 0) neighbors.push(index - 1); // Left
            if (x < boardSize - 1) neighbors.push(index + 1); // Right
            if (y > 0) neighbors.push(index - boardSize); // Up
            if (y < boardSize - 1) neighbors.push(index + boardSize); // Down
            
            return neighbors;
        }

        function getGroup(startIndex, boardData, boardSize) {
            const group = new Set();
            const stack = [startIndex];
            const player = boardData[startIndex];
            
            while (stack.length > 0) {
                const index = stack.pop();
                if (group.has(index)) continue;
                
                group.add(index);
                
                const neighbors = getNeighbors(index, boardSize);
                neighbors.forEach(neighborIndex => {
                    if (boardData[neighborIndex] === player && !group.has(neighborIndex)) {
                        stack.push(neighborIndex);
                    }
                });
            }
            
            return Array.from(group);
        }

        function hasNoLiberties(group, boardData, boardSize) {
            for (const index of group) {
                const neighbors = getNeighbors(index, boardSize);
                for (const neighborIndex of neighbors) {
                    if (boardData[neighborIndex] === null) {
                        return false; // Found a liberty
                    }
                }
            }
            return true; // No liberties found
        }

        async function handlePass() {
            if (!currentGameState || playerRole === 'spectator') return;
            if (currentGameState.status !== 'playing') return;
            
            const currentPlayerIndex = currentGameState.gameState.currentPlayer;
            
            if (!isOfflineMode) {
                const myPlayerIndex = currentGameState.players.indexOf(auth.currentUser.uid);
                if (currentPlayerIndex !== myPlayerIndex) return;
            }

            try {
                const newPassCount = currentGameState.gameState.passCount + 1;
                
                if (newPassCount >= 2) {
                    // Game ends
                    if (isOfflineMode) {
                        alert('Game ended by mutual pass.');
                        returnToLobby();
                    } else {
                        const winner = determineWinner(currentGameState.gameState);
                        await moveToRecentGames(currentGameState, winner, 'pass');
                        
                        const matchRef = doc(db, `artifacts/${appId}/matches`, currentMatchId);
                        await deleteDoc(matchRef);
                        
                        alert('Game ended by mutual pass');
                        returnToLobby();
                    }
                } else {
                    // Continue game with next player
                    const newGameState = {
                        ...currentGameState.gameState,
                        currentPlayer: 1 - currentPlayerIndex,
                        passCount: newPassCount
                    };

                    if (isOfflineMode) {
                        currentGameState.gameState = newGameState;
                        updateGameView(currentGameState);
                    } else {
                        const matchRef = doc(db, `artifacts/${appId}/matches`, currentMatchId);
                        await updateDoc(matchRef, {
                            gameState: newGameState,
                            lastActivity: serverTimestamp()
                        });
                    }
                }

            } catch (error) {
                console.error('Error passing:', error);
                alert('Failed to pass. Please try again.');
            }
        }

        function determineWinner(gameState) {
            // Simple scoring: first player wins (can be enhanced later)
            return currentGameState.players[0];
        }

        async function handleResign() {
            if (!currentGameState || playerRole === 'spectator') return;
            
            if (!confirm('Are you sure you want to resign?')) return;

            try {
                if (isOfflineMode) {
                    alert('You have resigned');
                    returnToLobby();
                } else {
                    const myPlayerIndex = currentGameState.players.indexOf(auth.currentUser.uid);
                    const opponentIndex = 1 - myPlayerIndex;
                    const winner = currentGameState.players[opponentIndex];
                    
                    await moveToRecentGames(currentGameState, winner, 'resignation');
                    
                    const matchRef = doc(db, `artifacts/${appId}/matches`, currentMatchId);
                    await deleteDoc(matchRef);
                    
                    alert('You have resigned');
                    returnToLobby();
                }

            } catch (error) {
                console.error('Error resigning:', error);
                alert('Failed to resign. Please try again.');
            }
        }

        async function leaveCurrentMatch() {
            if (!currentMatchId) return;

            if (playerRole !== 'spectator' && currentGameState && currentGameState.status === 'playing') {
                if (!confirm('Leaving will end the match. Are you sure?')) return;
                
                if (!isOfflineMode) {
                    // End the match
                    const myPlayerIndex = currentGameState.players.indexOf(auth.currentUser.uid);
                    const opponentIndex = 1 - myPlayerIndex;
                    const winner = currentGameState.players[opponentIndex];
                    
                    await moveToRecentGames(currentGameState, winner, 'abandonment');
                }
            }

            try {
                if (currentGameState && !isOfflineMode) {
                    const matchRef = doc(db, `artifacts/${appId}/matches`, currentMatchId);
                    
                    if (playerRole === 'spectator') {
                        // Just leave as spectator
                    } else {
                        // Delete the match
                        await deleteDoc(matchRef);
                    }
                }
            } catch (error) {
                console.error('Error leaving match:', error);
            }

            returnToLobby();
        }

        function startOfflineGame() {
            isOfflineMode = true;
            currentMatchId = 'offline';
            playerRole = 'player1';
            
            const boardSize = parseInt(boardSizeSelect.value);
            currentGameState = {
                matchCode: 'OFFLINE',
                boardSize: boardSize,
                players: ['offline_player1', 'offline_player2'],
                playerNames: {
                    'offline_player1': 'Player 1',
                    'offline_player2': 'Player 2'
                },
                status: 'playing',
                gameState: {
                    boardData: Array(boardSize * boardSize).fill(null),
                    currentPlayer: 0,
                    passCount: 0,
                    gameHistory: []
                }
            };
            
            showGameView();
            updateGameView(currentGameState);
            
            // In offline mode, allow both players to play
            passBtn.disabled = false;
            resignBtn.classList.remove('hidden');
            resignBtn.disabled = false;
        }

        function handlePageUnload() {
            if (currentMatchId && !isOfflineMode) {
                leaveCurrentMatch();
            }
        }

        // Initialize the app
        initApp();

    </script>
</body>
</html>
