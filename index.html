<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qirra</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Dongle:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --p1-color: #000000;
            --p1-glow-color: #ffffff;
            --p1-glow-size: 10px;
            --p2-color: #ffffff;
            --p2-glow-color: #00ffff;
            --p2-glow-size: 10px;
            --board-bg: #162447;
            --cell-bg: #1f4068;
            --cell-hover-bg: #1b3a5e;
        }
        body {
            font-family: 'Dongle', sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-size: 1.75rem;
            letter-spacing: 0.5px;
        }
        #game-title {
            font-family: 'Cinzel', serif;
        }
        .board {
            display: grid;
            gap: 1px;
            background-color: var(--board-bg);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            pointer-events: none; /* Disabled until a match starts */
            opacity: 0.5;
        }
        .board.active {
            pointer-events: auto;
            opacity: 1;
        }
        .cell {
            position: relative;
            background-color: var(--cell-bg);
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .cell:hover {
            background-color: var(--cell-hover-bg);
        }
        .stone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            border-radius: 50%;
            transition: border-radius 0.2s ease-in-out, background-color 0.3s, box-shadow 0.3s;
        }
        .black {
            background-color: var(--p1-color);
            box-shadow: 0 0 var(--p1-glow-size) var(--p1-glow-color);
        }
        .white {
            background-color: var(--p2-color);
            box-shadow: 0 0 var(--p2-glow-size) var(--p2-glow-color);
        }
        .controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .controls, .slider-control {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        .btn {
            background-color: var(--cell-bg);
            color: #e0e0e0;
            padding: 5px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
            margin: 0 10px;
            border: 2px solid transparent;
            font-size: 1.5rem;
        }
        .btn:hover {
            background-color: var(--cell-hover-bg);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn.resign {
            background-color: #dc2626;
            border-color: #ef4444;
        }
        .btn.resign:hover {
            background-color: #b91c1c;
        }
        .scoreboard {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
            width: 350px;
        }
        #game-status, #online-count-container {
            height: 2.5rem;
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 5px;
        }
        #spectator-info {
            font-size: 1.2rem;
            color: #fbbf24;
            text-align: center;
            margin-bottom: 5px;
        }
        #player-info {
            transition: all 0.3s ease;
        }
        #player-info.active-turn {
            transform: scale(1.02);
        }
        .player-turn-highlight {
            background-color: var(--p2-glow-color) !important;
            box-shadow: 0 0 15px var(--p2-glow-color);
            transform: scale(1.05);
            transition: all 0.3s ease;
        }
        #current-turn-indicator {
            color: var(--p2-glow-color);
            text-shadow: 0 0 10px var(--p2-glow-color);
        }
        /* Modal Styles */
        .modal {
            position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.6);
        }
        .modal-content {
            background-color: #1a1a2e; margin: 10% auto; padding: 20px;
            border: 1px solid var(--p2-glow-color); border-radius: 10px;
            width: 80%; max-width: 500px; box-shadow: 0 0 20px var(--p2-glow-color);
            position: relative;
        }
        .close-btn {
            color: #aaa; position: absolute; top: 10px; right: 25px;
            font-size: 2.5rem; font-weight: bold; cursor: pointer;
        }
        .close-btn:hover, .close-btn:focus { color: white; }
        .settings-grid { display: grid; grid-template-columns: auto 1fr; gap: 15px; align-items: center; }
        .settings-grid h3 {
            grid-column: 1 / -1; font-family: 'Cinzel', serif; color: var(--p2-glow-color);
            border-bottom: 1px solid var(--p2-glow-color); padding-bottom: 5px;
        }
        input[type=range] { -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; width: 100%; }
        input[type=range]::-webkit-slider-runnable-track { height: 8px; background: var(--cell-bg); border-radius: 5px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%; background: var(--p2-glow-color); margin-top: -8px; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <h1 id="game-title" class="text-5xl font-bold mb-4">Qirra</h1>
    <div class="controls-container mb-4">
        <div class="slider-control">
            <label for="size-slider" class="mr-4">Size:</label>
            <input type="range" id="size-slider" min="5" max="25" value="8">
            <span id="size-label" class="ml-4 w-16 text-center">8x8</span>
        </div>
        <input id="player-name" type="text" placeholder="Enter your name" class="mt-2 p-2 rounded bg-[var(--cell-bg)] text-center" maxlength="20" />
        <input id="match-code" type="text" placeholder="Match code (optional)" class="mt-2 p-2 rounded bg-[var(--cell-bg)] text-center" />
    </div>
    <div id="online-count-container">Players Online: <span id="online-count">0</span></div>
    <div id="spectator-info" class="hidden">Spectators: <span id="spectator-count">0</span></div>
    <div id="game-status">Ready to play.</div>
    <div id="player-info" class="hidden mb-4 text-center">
        <div class="flex justify-center items-center gap-4 mb-2">
            <div id="player1-info" class="flex items-center gap-2 p-2 rounded" style="background-color: var(--cell-bg);">
                <div class="w-4 h-4 rounded-full bg-black" style="box-shadow: 0 0 8px white;"></div>
                <span id="player1-name">Player 1</span>
            </div>
            <div class="text-2xl font-bold">VS</div>
            <div id="player2-info" class="flex items-center gap-2 p-2 rounded" style="background-color: var(--cell-bg);">
                <div class="w-4 h-4 rounded-full bg-white" style="box-shadow: 0 0 8px cyan;"></div>
                <span id="player2-name">Player 2</span>
            </div>
        </div>
        <div id="current-turn-indicator" class="text-lg font-semibold"></div>
    </div>
    <div class="scoreboard">
        <div><span id="player1-score-label">Player 1</span>: <span id="black-score">0</span></div>
        <div><span id="player2-score-label">Player 2</span>: <span id="white-score">0</span></div>
    </div>
    <div class="board" id="board"></div>
    <div class="controls">
        <div class="btn" id="matchmaking-btn">Find Match</div>
        <div class="btn" id="offline-btn">Play Offline</div>
        <div class="btn" id="pass-btn" disabled>Pass</div>
        <div class="btn resign hidden" id="resign-btn">Resign</div>
        <div class="btn" id="settings-btn">Settings</div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal hidden">
        <div class="modal-content">
            <span id="close-modal" class="close-btn">&times;</span>
            <h2 class="text-3xl mb-4" style="font-family: 'Cinzel', serif;">Settings</h2>
            <div class="settings-grid">
                <h3>Player 1</h3>
                <label for="p1-color-picker">Tile Color</label> <input type="color" id="p1-color-picker" value="#000000">
                <label for="p1-glow-color-picker">Glow Color</label> <input type="color" id="p1-glow-color-picker" value="#ffffff">
                <label for="p1-glow-size-slider">Glow Size</label> <input type="range" id="p1-glow-size-slider" min="0" max="20" value="10">
                <h3>Player 2</h3>
                <label for="p2-color-picker">Tile Color</label> <input type="color" id="p2-color-picker" value="#ffffff">
                <label for="p2-glow-color-picker">Glow Color</label> <input type="color" id="p2-glow-color-picker" value="#00ffff">
                <label for="p2-glow-size-slider">Glow Size</label> <input type="range" id="p2-glow-size-slider" min="0" max="20" value="10">
                <h3>Board</h3>
                <label for="board-bg-picker">Board Color</label> <input type="color" id="board-bg-picker" value="#162447">
                <label for="cell-bg-picker">Cell Color</label> <input type="color" id="cell-bg-picker" value="#1f4068">
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, limit, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getDatabase, ref, onValue, set, onDisconnect, remove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // DOM Elements
        const boardEl = document.getElementById('board');
        const p1ScoreEl = document.getElementById('black-score');
        const p2ScoreEl = document.getElementById('white-score');
        const passBtn = document.getElementById('pass-btn');
        const resignBtn = document.getElementById('resign-btn');
        const matchmakingBtn = document.getElementById('matchmaking-btn');
        const offlineBtn = document.getElementById('offline-btn');
        const sizeSlider = document.getElementById('size-slider');
        const sizeLabel = document.getElementById('size-label');
        const statusEl = document.getElementById('game-status');
        const onlineCountEl = document.getElementById('online-count');
        const spectatorInfoEl = document.getElementById('spectator-info');
        const spectatorCountEl = document.getElementById('spectator-count');
        const matchCodeInput = document.getElementById('match-code');
        const playerNameInput = document.getElementById('player-name');
        const playerInfoEl = document.getElementById('player-info');
        const player1NameEl = document.getElementById('player1-name');
        const player2NameEl = document.getElementById('player2-name');
        const player1InfoEl = document.getElementById('player1-info');
        const player2InfoEl = document.getElementById('player2-info');
        const currentTurnIndicatorEl = document.getElementById('current-turn-indicator');
        const player1ScoreLabelEl = document.getElementById('player1-score-label');
        const player2ScoreLabelEl = document.getElementById('player2-score-label');

        // --- Firebase Setup ---
        const appId = 'qirra-default';
        
        // Firebase configuration - Load from external sources
        let firebaseConfig = {};
        
        // Try to load configuration from multiple sources
        async function loadFirebaseConfig() {
            try {
                // Method 1: Try to import from external config file
                try {
                    const configModule = await import('./firebase-config.js');
                    firebaseConfig = configModule.firebaseConfig;
                    console.log('Loaded Firebase config from external file');
                } catch (importError) {
                    console.log('External config file not found, trying other methods...');
                }
                
                // Method 2: Check for environment variables (if available)
                if (typeof process !== 'undefined' && process.env) {
                    const envConfig = {
                        apiKey: process.env.FIREBASE_API_KEY,
                        authDomain: process.env.FIREBASE_AUTH_DOMAIN,
                        databaseURL: process.env.FIREBASE_DATABASE_URL,
                        projectId: process.env.FIREBASE_PROJECT_ID,
                        storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
                        messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
                        appId: process.env.FIREBASE_APP_ID
                    };
                    
                    // Only use env config if all required fields are present
                    if (envConfig.apiKey && envConfig.projectId) {
                        firebaseConfig = envConfig;
                        console.log('Loaded Firebase config from environment variables');
                    }
                }
                
                // Method 3: Check for global window variables (for runtime injection)
                if (typeof window !== 'undefined' && window.FIREBASE_CONFIG) {
                    firebaseConfig = window.FIREBASE_CONFIG;
                    console.log('Loaded Firebase config from window.FIREBASE_CONFIG');
                }
                
                // Method 4: Fallback to inline configuration (development only)
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "your-api-key-here") {
                    firebaseConfig = {
                        apiKey: "your-api-key-here",
                        authDomain: "your-project.firebaseapp.com",
                        databaseURL: "https://your-project-default-rtdb.firebaseio.com",
                        projectId: "your-project-id",
                        storageBucket: "your-project.appspot.com",
                        messagingSenderId: "123456789",
                        appId: "1:123456789:web:abcdef123456"
                    };
                    console.log('Using fallback Firebase config (development mode)');
                }
                
            } catch (error) {
                console.error('Error loading Firebase configuration:', error);
            }
        }

        let app, db, rtdb, auth, analytics;
        matchmakingBtn.disabled = true;

        // --- Game State ---
        let localState = {
            boardSize: 8,
            boardData: [],
            p1Score: 0,
            p2Score: 0,
            currentPlayerId: 'player1', // Start with player1 in offline mode
            players: ['player1', 'player2'], // Default offline players
            spectators: [], // List of spectator UIDs
            passCount: 0,
            previousStates: [],
            isOfflineMode: false,
            gameStarted: false,
            gameEnded: false,
            isSpectating: false
        };
        let currentGameId = null;
        let unsubscribeGame = null;
        let unsubscribeWaiting = null;
        let presenceRef = null;

        // --- Core Game Logic ---
        async function initializeAppLogic() {
            // Load Firebase configuration from external sources
            await loadFirebaseConfig();
            
            try {
                // Check if Firebase config has real values (not placeholder)
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "your-api-key-here") {
                    throw new Error('Firebase configuration not set up. Please replace placeholder values with your actual Firebase project configuration.');
                }
                
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                rtdb = getDatabase(app);
                auth = getAuth(app);
                
                // Initialize Analytics (optional - only if supported)
                try {
                    analytics = getAnalytics(app);
                    console.log("Firebase Analytics initialized");
                } catch (analyticsError) {
                    console.log("Analytics not available:", analyticsError.message);
                }

                await signInAnonymously(auth);
                console.log("Authenticated with UID:", auth.currentUser.uid);
                setupPresence(); // Set up online status
                matchmakingBtn.disabled = false;
                statusEl.textContent = "Ready to play online!";
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                statusEl.textContent = "Offline mode only - Firebase not configured.";
                onlineCountEl.textContent = "N/A";
            }
            setupUI();
        }

        function setupPresence() {
            presenceRef = ref(rtdb, 'status/' + auth.currentUser.uid);
            onDisconnect(presenceRef).remove();
            set(presenceRef, { 
                online: true, 
                lastSeen: serverTimestamp(),
                playerName: playerNameInput.value.trim() || 'Anonymous'
            });

            const statusRef = ref(rtdb, 'status');
            onValue(statusRef, (snapshot) => {
                onlineCountEl.textContent = snapshot.numChildren();
            });

            // Handle page visibility changes and beforeunload
            window.addEventListener('beforeunload', handlePageUnload);
        }

        function handlePageUnload() {
            if (currentGameId && !localState.isOfflineMode) {
                handlePlayerLeave();
            }
        }

        async function handlePlayerLeave() {
            if (!currentGameId || localState.isOfflineMode) return;
            
            try {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                const gameDoc = await getDoc(gameRef);
                
                if (gameDoc.exists()) {
                    const gameData = gameDoc.data();
                    
                    if (localState.isSpectating) {
                        // Remove from spectators
                        const updatedSpectators = gameData.spectators.filter(id => id !== auth.currentUser.uid);
                        await updateDoc(gameRef, { spectators: updatedSpectators });
                    } else if (gameData.players.includes(auth.currentUser.uid)) {
                        // Player is leaving - end the game
                        await updateDoc(gameRef, { 
                            gameEnded: true,
                            winner: gameData.players.find(p => p !== auth.currentUser.uid),
                            endReason: 'resignation',
                            endedAt: serverTimestamp()
                        });
                    }
                }
            } catch (error) {
                console.error('Error handling player leave:', error);
            }
        }

        function setupUI() {
            createBoard();
            matchmakingBtn.addEventListener('click', findMatch);
            offlineBtn.addEventListener('click', startOfflineGame);
            passBtn.addEventListener('click', handlePass);
            resignBtn.addEventListener('click', handleResign);
            sizeSlider.addEventListener('input', e => sizeLabel.textContent = `${e.target.value}x${e.target.value}`);
            sizeSlider.addEventListener('change', e => {
                if (!currentGameId && !localState.gameStarted) { // Only allow size change if not in a game
                    localState.boardSize = parseInt(e.target.value);
                    createBoard();
                }
            });
        }

        async function findMatch() {
            if (!auth || !db) {
                statusEl.textContent = "Matchmaking unavailable.";
                return;
            }
            
            if (currentGameId) {
                // Leave current game
                await handlePlayerLeave();
                resetToLobby();
                return;
            }

            if (unsubscribeWaiting) unsubscribeWaiting();
            matchmakingBtn.disabled = true;
            statusEl.textContent = "Searching for a game...";

            // Use null for general matchmaking when no code is entered
            const enteredCode = matchCodeInput.value.trim();
            const code = enteredCode || null;
            const isGeneralMatchmaking = !enteredCode;
            const desiredBoardSize = localState.boardSize;
            const myPlayerName = playerNameInput.value.trim() || 'Anonymous';
            
            // First, check if there's an existing active game with this code
            const gamesRef = collection(db, `artifacts/${appId}/public/data/games`);
            const existingGameQuery = query(gamesRef, where('code', '==', code), where('gameEnded', '==', false));
            const existingGames = await getDocs(existingGameQuery);
            
            if (!existingGames.empty) {
                // Found an existing game
                const gameDoc = existingGames.docs[0];
                const gameData = gameDoc.data();
                
                if (gameData.players.length < 2 && !gameData.players.includes(auth.currentUser.uid)) {
                    // Join as second player
                    const updatedPlayers = [...gameData.players, auth.currentUser.uid];
                    const updatedPlayerNames = {
                        ...gameData.playerNames,
                        [auth.currentUser.uid]: myPlayerName
                    };
                    
                    await updateDoc(gameDoc.ref, {
                        players: updatedPlayers,
                        playerNames: updatedPlayerNames,
                        gameStarted: true
                    });
                    
                    joinGame(gameDoc.id, false);
                } else if (!gameData.players.includes(auth.currentUser.uid) && !(gameData.spectators && gameData.spectators.includes(auth.currentUser.uid))) {
                    // Join as spectator
                    const updatedSpectators = [...(gameData.spectators || []), auth.currentUser.uid];
                    const updatedSpectatorNames = {
                        ...(gameData.spectatorNames || {}),
                        [auth.currentUser.uid]: myPlayerName
                    };
                    
                    await updateDoc(gameDoc.ref, {
                        spectators: updatedSpectators,
                        spectatorNames: updatedSpectatorNames
                    });
                    
                    joinGame(gameDoc.id, true);
                }
                return;
            }
            
            // No existing game, check waiting pool
            const waitingPoolRef = collection(db, `artifacts/${appId}/public/data/waiting_pool`);
            const q = query(waitingPoolRef, where('code', '==', code), where('boardSize', '==', desiredBoardSize), limit(1));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                // No one is waiting, so we wait
                statusEl.textContent = isGeneralMatchmaking ? "Waiting for any opponent..." : `Waiting for opponent with code "${enteredCode}"...`;
                const myWaitingRef = doc(db, `artifacts/${appId}/public/data/waiting_pool`, auth.currentUser.uid);
                await setDoc(myWaitingRef, { 
                    waitingSince: serverTimestamp(), 
                    boardSize: desiredBoardSize, 
                    code: code,
                    playerName: myPlayerName,
                    isGeneralMatchmaking: isGeneralMatchmaking
                });

                // Listen for our waiting doc to be deleted, which means we've been matched
                unsubscribeWaiting = onSnapshot(myWaitingRef, (doc) => {
                    if (!doc.exists()) {
                        if(unsubscribeWaiting) unsubscribeWaiting();
                        listenForGameInvite();
                    }
                });

            } else {
                // Found a waiting player, let's start a game
                const opponentDoc = querySnapshot.docs[0];
                const opponentId = opponentDoc.id;
                const opponentData = opponentDoc.data();
                const opponentName = opponentData.playerName || 'Anonymous';

                // Delete opponent from waiting pool
                await deleteDoc(opponentDoc.ref);

                // Create a new game
                const newGameId = `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const players = Math.random() < 0.5 ? [auth.currentUser.uid, opponentId] : [opponentId, auth.currentUser.uid];
                
                const playerNames = {};
                playerNames[players[0]] = players[0] === auth.currentUser.uid ? myPlayerName : opponentName;
                playerNames[players[1]] = players[1] === auth.currentUser.uid ? myPlayerName : opponentName;

                // For general matchmaking, generate a unique game code for the created game
                const gameCode = isGeneralMatchmaking ? generateRandomCode() : code;

                const newGameData = {
                    players,
                    playerNames,
                    spectators: [],
                    spectatorNames: {},
                    boardSize: desiredBoardSize,
                    boardData: Array(desiredBoardSize * desiredBoardSize).fill(null),
                    p1Score: 0,
                    p2Score: 0,
                    currentPlayerId: players[0],
                    passCount: 0,
                    previousStates: [],
                    createdAt: serverTimestamp(),
                    gameId: newGameId,
                    code: gameCode,
                    gameStarted: true,
                    gameEnded: false
                };

                await setDoc(doc(db, `artifacts/${appId}/public/data/games`, newGameId), newGameData);
                listenForGameInvite();
            }
        }

        function generateRandomCode() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }
        
        function listenForGameInvite() {
            if (unsubscribeGame) unsubscribeGame();
            
            const gamesRef = collection(db, `artifacts/${appId}/public/data/games`);
            const playerQuery = query(gamesRef, where('players', 'array-contains', auth.currentUser.uid), where('gameEnded', '==', false));
            const spectatorQuery = query(gamesRef, where('spectators', 'array-contains', auth.currentUser.uid), where('gameEnded', '==', false));

            // Listen for games where I'm a player
            unsubscribeGame = onSnapshot(playerQuery, (snapshot) => {
                if (!snapshot.empty) {
                    const gameDoc = snapshot.docs[0]; // Join the first active game found
                    if (gameDoc.id !== currentGameId) {
                        joinGame(gameDoc.id, false);
                    } else {
                        updateLocalState(gameDoc.data());
                        renderGame();
                    }
                }
            });

            // Also listen for games where I'm a spectator
            onSnapshot(spectatorQuery, (snapshot) => {
                if (!snapshot.empty && !currentGameId) {
                    const gameDoc = snapshot.docs[0];
                    joinGame(gameDoc.id, true);
                }
            });
        }

        function joinGame(gameId, isSpectating = false) {
            if (unsubscribeWaiting) unsubscribeWaiting();
            currentGameId = gameId;
            localState.isSpectating = isSpectating;
            
            statusEl.textContent = isSpectating ? "Joined as spectator" : "Game found! Starting...";
            
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            
            if (unsubscribeGame) unsubscribeGame();
            unsubscribeGame = onSnapshot(gameRef, (doc) => {
                if (doc.exists()) {
                    const gameData = doc.data();
                    if (gameData.gameEnded) {
                        endGame(getEndGameMessage(gameData));
                        return;
                    }
                    updateLocalState(gameData);
                    renderGame();
                } else {
                    endGame("Game was deleted.");
                }
            });
        }

        function getEndGameMessage(gameData) {
            if (gameData.endReason === 'resignation') {
                const winnerName = gameData.playerNames[gameData.winner] || 'Unknown';
                const loserName = gameData.playerNames[gameData.players.find(p => p !== gameData.winner)] || 'Unknown';
                return `${loserName} resigned. ${winnerName} wins!`;
            } else if (gameData.endReason === 'pass') {
                const winner = gameData.p1Score > gameData.p2Score ? gameData.players[0] : 
                              gameData.p2Score > gameData.p1Score ? gameData.players[1] : null;
                if (winner) {
                    const winnerName = gameData.playerNames[winner] || 'Unknown';
                    return `Game ended. ${winnerName} wins!`;
                } else {
                    return "Game ended. It's a tie!";
                }
            }
            return "Game ended.";
        }

        function updateLocalState(gameData) {
            localState = { ...localState, ...gameData };
        }

        function renderGame() {
            if (localState.boardSize !== parseInt(boardEl.style.gridTemplateColumns.split('(')[1])) {
                createBoard();
            }
            renderBoard();
            updatePlayerInfo();
            updateSpectatorInfo();
            
            if (localState.isSpectating) {
                statusEl.textContent = "Spectating game";
                boardEl.classList.add('active'); // Allow spectators to see the board
                passBtn.disabled = true;
                resignBtn.classList.add('hidden');
                matchmakingBtn.textContent = 'Leave Game';
                matchmakingBtn.disabled = false;
                matchmakingBtn.onclick = leaveGame;
            } else {
                const myTurn = localState.currentPlayerId === auth.currentUser.uid;
                const amIPlayer1 = localState.players[0] === auth.currentUser.uid;
                const myRole = amIPlayer1 ? 'Player 1 (Black)' : 'Player 2 (White)';

                statusEl.textContent = myTurn ? `Your turn, ${myRole}` : `Opponent's turn...`;
                boardEl.classList.add('active');
                passBtn.disabled = !myTurn;
                resignBtn.classList.remove('hidden');
                resignBtn.disabled = false;
                matchmakingBtn.textContent = 'Leave Game';
                matchmakingBtn.disabled = false;
                matchmakingBtn.onclick = leaveGame;
            }
            
            sizeSlider.disabled = true;
            playerNameInput.disabled = true;
            matchCodeInput.disabled = true;
        }

        function updateSpectatorInfo() {
            if (localState.spectators && localState.spectators.length > 0) {
                spectatorInfoEl.classList.remove('hidden');
                spectatorCountEl.textContent = localState.spectators.length;
            } else {
                spectatorInfoEl.classList.add('hidden');
            }
        }

        function createBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${localState.boardSize}, 1fr)`;
            boardEl.style.gridTemplateRows = `repeat(${localState.boardSize}, 1fr)`;
            const boardPixelWidth = Math.min(window.innerWidth, window.innerHeight) * 0.7;
            boardEl.style.width = `${boardPixelWidth}px`;
            boardEl.style.height = `${boardPixelWidth}px`;
            for (let i = 0; i < localState.boardSize * localState.boardSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                boardEl.appendChild(cell);
            }
        }

        function renderBoard() {
            Array.from(boardEl.children).forEach((cell, i) => {
                // Clear previous stone
                while (cell.firstChild) {
                    cell.removeChild(cell.firstChild);
                }
                // Add new stone if it exists in state
                if (localState.boardData[i]) {
                    const stone = document.createElement('div');
                    const playerClass = localState.boardData[i]; // 'black' or 'white'
                    stone.classList.add('stone', playerClass);
                    stone.style.borderRadius = getBorderRadiusForStone(i);
                    cell.appendChild(stone);
                }
            });
        }

        async function handleCellClick(e) {
            // Spectators can't make moves
            if (localState.isSpectating) return;
            
            // Check if it's the current player's turn
            if (localState.isOfflineMode) {
                // In offline mode, allow any player to play
            } else {
                if (localState.currentPlayerId !== auth.currentUser.uid) return; // Not my turn in online mode
            }

            const index = parseInt(e.currentTarget.dataset.index);
            if (localState.boardData[index]) return; // Cell is not empty

            let playerColor;
            if (localState.isOfflineMode) {
                playerColor = localState.currentPlayerId === 'player1' ? 'black' : 'white';
            } else {
                playerColor = localState.players.indexOf(auth.currentUser.uid) === 0 ? 'black' : 'white';
            }
            
            // Create a temporary board to test the move
            let tempBoard = [...localState.boardData];
            tempBoard[index] = playerColor;
            
            const opponentColor = playerColor === 'black' ? 'white' : 'black';
            let capturedStones = 0;
            
            // 1. Check for captures of opponent stones
            getNeighbors(index, localState.boardSize).forEach(n => {
                if (tempBoard[n] === opponentColor) {
                    const group = getGroup(n, tempBoard, localState.boardSize);
                    if (hasNoLiberties(group, tempBoard, localState.boardSize)) {
                        capturedStones += group.length;
                        group.forEach(i => tempBoard[i] = null); // Remove captured stones
                    }
                }
            });

            // 2. Check for suicide
            const ownGroup = getGroup(index, tempBoard, localState.boardSize);
            if (hasNoLiberties(ownGroup, tempBoard, localState.boardSize)) {
                statusEl.textContent = "Suicide moves are not allowed.";
                setTimeout(() => { 
                    if (localState.isOfflineMode) {
                        renderOfflineGame();
                    } else {
                        renderGame();
                    }
                }, 2000);
                return;
            }

            // 3. Check for Ko rule (preventing repeating board state)
            const stateString = tempBoard.join('');
            if (localState.previousStates.includes(stateString)) {
                statusEl.textContent = "Move is not allowed due to the Ko rule.";
                setTimeout(() => { 
                    if (localState.isOfflineMode) {
                        renderOfflineGame();
                    } else {
                        renderGame();
                    }
                }, 2000);
                return;
            }

            // Update scores
            let newP1Score = localState.p1Score;
            let newP2Score = localState.p2Score;
            if (playerColor === 'black') newP1Score += capturedStones;
            else newP2Score += capturedStones;

            // Update local state
            localState.boardData = tempBoard;
            localState.p1Score = newP1Score;
            localState.p2Score = newP2Score;
            localState.passCount = 0; // Reset pass count on a valid move
            localState.previousStates = [...localState.previousStates.slice(-10), stateString]; // Keep last 10 states

            if (localState.isOfflineMode) {
                // Switch players in offline mode
                localState.currentPlayerId = localState.currentPlayerId === 'player1' ? 'player2' : 'player1';
                renderOfflineGame();
            } else {
                // Update Firestore for online mode
                const nextPlayerId = localState.players.find(p => p !== auth.currentUser.uid);
                localState.currentPlayerId = nextPlayerId;
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                
                await updateDoc(gameRef, {
                    boardData: tempBoard,
                    currentPlayerId: nextPlayerId,
                    passCount: 0,
                    p1Score: newP1Score,
                    p2Score: newP2Score,
                    previousStates: localState.previousStates
                });
            }
        }

        async function handlePass() {
            if (localState.isSpectating) return;
            
            if (localState.isOfflineMode) {
                // In offline mode, allow pass
            } else {
                if (localState.currentPlayerId !== auth.currentUser.uid) return; // Not my turn in online mode
            }
            
            const newPassCount = localState.passCount + 1;
            localState.passCount = newPassCount;
            
            if (newPassCount >= 2) {
                // Game ends
                if (localState.isOfflineMode) {
                    const winner = localState.p1Score > localState.p2Score ? "Player 1 Wins!" : 
                                  localState.p2Score > localState.p1Score ? "Player 2 Wins!" : "It's a tie!";
                    statusEl.textContent = `Game Over. ${winner}`;
                    passBtn.disabled = true;
                    resignBtn.disabled = true;
                } else {
                    // End online game
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                    await updateDoc(gameRef, {
                        gameEnded: true,
                        endReason: 'pass',
                        endedAt: serverTimestamp()
                    });
                }
            } else {
                if (localState.isOfflineMode) {
                    // Switch players in offline mode
                    localState.currentPlayerId = localState.currentPlayerId === 'player1' ? 'player2' : 'player1';
                    renderOfflineGame();
                } else {
                    // Update Firestore for online mode
                    const nextPlayerId = localState.players.find(p => p !== auth.currentUser.uid);
                    localState.currentPlayerId = nextPlayerId;
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                    await updateDoc(gameRef, {
                        currentPlayerId: nextPlayerId,
                        passCount: newPassCount
                    });
                }
            }
        }

        async function handleResign() {
            if (localState.isSpectating) return;
            
            if (localState.isOfflineMode) {
                const winner = localState.currentPlayerId === 'player1' ? 'Player 2' : 'Player 1';
                statusEl.textContent = `${localState.currentPlayerId === 'player1' ? 'Player 1' : 'Player 2'} resigned. ${winner} wins!`;
                passBtn.disabled = true;
                resignBtn.disabled = true;
                setTimeout(resetToLobby, 3000);
            } else {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                const winner = localState.players.find(p => p !== auth.currentUser.uid);
                await updateDoc(gameRef, {
                    gameEnded: true,
                    winner: winner,
                    endReason: 'resignation',
                    endedAt: serverTimestamp()
                });
            }
        }
        
        async function leaveGame() {
            await handlePlayerLeave();
            resetToLobby();
        }

        function endGame(message) {
            statusEl.textContent = message;
            
            // Clean up the game document from Firestore after a delay
            if (currentGameId && !localState.isOfflineMode) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                setTimeout(() => {
                    deleteDoc(gameRef).catch(err => console.error("Error deleting game doc:", err));
                }, 5000); // Wait 5 seconds before deleting
            }
            
            setTimeout(() => resetToLobby(), 3000);
        }
        
        function startOfflineGame() {
            // Reset game state for offline mode
            localState = {
                boardSize: parseInt(sizeSlider.value),
                boardData: Array(parseInt(sizeSlider.value) * parseInt(sizeSlider.value)).fill(null),
                p1Score: 0,
                p2Score: 0,
                currentPlayerId: 'player1',
                players: ['player1', 'player2'],
                spectators: [],
                passCount: 0,
                previousStates: [],
                isOfflineMode: true,
                gameStarted: true,
                gameEnded: false,
                isSpectating: false
            };
            
            createBoard();
            renderOfflineGame();
            
            // Update UI for offline game
            matchmakingBtn.textContent = 'End Game';
            matchmakingBtn.onclick = endOfflineGame;
            offlineBtn.style.display = 'none';
            sizeSlider.disabled = true;
            playerNameInput.disabled = true;
            matchCodeInput.disabled = true;
            statusEl.textContent = "Player 1's turn (Black)";
            boardEl.classList.add('active');
            passBtn.disabled = false;
            resignBtn.classList.remove('hidden');
            resignBtn.disabled = false;
        }

        function updatePlayerInfo() {
            // Show player info panel
            playerInfoEl.classList.remove('hidden');
            
            // Get player names
            let player1Name, player2Name;
            
            if (localState.isOfflineMode) {
                player1Name = 'Player 1';
                player2Name = 'Player 2';
            } else {
                // Use stored player names from game data
                if (localState.playerNames && localState.players) {
                    player1Name = localState.playerNames[localState.players[0]] || 'Player 1';
                    player2Name = localState.playerNames[localState.players[1]] || 'Player 2';
                } else {
                    // Fallback to old behavior if playerNames not available
                    const playerName = playerNameInput.value.trim() || 'You';
                    const amIPlayer1 = localState.players[0] === auth.currentUser.uid;
                    player1Name = amIPlayer1 ? playerName : 'Opponent';
                    player2Name = amIPlayer1 ? 'Opponent' : playerName;
                }
            }
            
            // Update player names and score labels
            player1NameEl.textContent = player1Name;
            player2NameEl.textContent = player2Name;
            player1ScoreLabelEl.textContent = player1Name;
            player2ScoreLabelEl.textContent = player2Name;
            
            // Update scores
            p1ScoreEl.textContent = localState.p1Score;
            p2ScoreEl.textContent = localState.p2Score;
            
            // Update turn indicator and highlights
            const isPlayer1Turn = localState.currentPlayerId === (localState.isOfflineMode ? 'player1' : localState.players[0]);
            
            // Remove previous highlights
            player1InfoEl.classList.remove('player-turn-highlight');
            player2InfoEl.classList.remove('player-turn-highlight');
            
            // Add highlight to current player
            if (isPlayer1Turn) {
                player1InfoEl.classList.add('player-turn-highlight');
                currentTurnIndicatorEl.textContent = `${player1Name}'s turn`;
            } else {
                player2InfoEl.classList.add('player-turn-highlight');
                currentTurnIndicatorEl.textContent = `${player2Name}'s turn`;
            }
        }

        function renderOfflineGame() {
            renderBoard();
            updatePlayerInfo();
            
            const currentPlayer = localState.currentPlayerId === 'player1' ? 'Player 1 (Black)' : 'Player 2 (White)';
            statusEl.textContent = `Game Started - ${currentPlayer}'s turn`;
            
            passBtn.disabled = false;
            resignBtn.disabled = false;
            playerNameInput.disabled = true;
            matchCodeInput.disabled = true;
        }

        function endOfflineGame() {
            resetToLobby();
        }

        function resetToLobby() {
            if (unsubscribeGame) unsubscribeGame();
            unsubscribeGame = null;
            currentGameId = null;
            
            // Reset offline mode state
            localState.isOfflineMode = false;
            localState.gameStarted = false;
            localState.gameEnded = false;
            localState.isSpectating = false;
            
            boardEl.classList.remove('active');
            passBtn.disabled = true;
            resignBtn.classList.add('hidden');
            resignBtn.disabled = true;
            matchmakingBtn.textContent = 'Find Match';
            matchmakingBtn.disabled = false;
            matchmakingBtn.onclick = findMatch;
            offlineBtn.style.display = 'inline-block';
            sizeSlider.disabled = false;
            playerNameInput.disabled = false;
            matchCodeInput.disabled = false;
            statusEl.textContent = "Ready to play.";
            
            // Hide player info panel and spectator info
            playerInfoEl.classList.add('hidden');
            spectatorInfoEl.classList.add('hidden');
            
            // Remove any turn highlights
            player1InfoEl.classList.remove('player-turn-highlight');
            player2InfoEl.classList.remove('player-turn-highlight');
            
            // Re-initialize board to default size
            localState.boardSize = parseInt(sizeSlider.value);
            localState.boardData = Array(localState.boardSize * localState.boardSize).fill(null);
            localState.p1Score = 0;
            localState.p2Score = 0;
            localState.passCount = 0;
            localState.previousStates = [];
            localState.spectators = [];
            createBoard();
            renderBoard(); // Render the empty board
            p1ScoreEl.textContent = '0';
            p2ScoreEl.textContent = '0';
            
            // Reset score labels to default
            player1ScoreLabelEl.textContent = 'Player 1';
            player2ScoreLabelEl.textContent = 'Player 2';
        }

        // --- Helper Functions ---
        function getBorderRadiusForStone(index) {
            const color = localState.boardData[index];
            if (!color) return '50%';
            const { boardSize, boardData } = localState;
            const x = index % boardSize;
            const y = Math.floor(index / boardSize);
            const hasTopNeighbor = y > 0 && boardData[index - boardSize] === color;
            const hasRightNeighbor = x < boardSize - 1 && boardData[index + 1] === color;
            const hasBottomNeighbor = y < boardSize - 1 && boardData[index + boardSize] === color;
            const hasLeftNeighbor = x > 0 && boardData[index - 1] === color;
            const round = '50%', flat = '20%';
            const topLeft = (hasTopNeighbor || hasLeftNeighbor) ? flat : round;
            const topRight = (hasTopNeighbor || hasRightNeighbor) ? flat : round;
            const bottomRight = (hasBottomNeighbor || hasRightNeighbor) ? flat : round;
            const bottomLeft = (hasBottomNeighbor || hasLeftNeighbor) ? flat : round;
            return `${topLeft} ${topRight} ${bottomRight} ${bottomLeft}`;
        }
        
        function getNeighbors(index, boardSize) {
            const neighbors = [];
            const x = index % boardSize, y = Math.floor(index / boardSize);
            if (x > 0) neighbors.push(index - 1);
            if (x < boardSize - 1) neighbors.push(index + 1);
            if (y > 0) neighbors.push(index - boardSize);
            if (y < boardSize - 1) neighbors.push(index + boardSize);
            return neighbors;
        }
        
        function getGroup(startIndex, boardData, boardSize) {
            if (boardData[startIndex] === null) return [];
            const group = new Set([startIndex]), queue = [startIndex], color = boardData[startIndex], visited = new Set([startIndex]);
            while (queue.length > 0) {
                const currentIndex = queue.shift();
                getNeighbors(currentIndex, boardSize).forEach(neighborIndex => {
                    if (!visited.has(neighborIndex) && boardData[neighborIndex] === color) {
                        visited.add(neighborIndex);
                        group.add(neighborIndex);
                        queue.push(neighborIndex);
                    }
                });
            }
            return Array.from(group);
        }
        
        function hasNoLiberties(group, boardData, boardSize) {
            if (group.length === 0) return false;
            for (const stoneIndex of group) {
                if (getNeighbors(stoneIndex, boardSize).some(neighborIndex => boardData[neighborIndex] === null)) return false;
            }
            return true;
        }

        // --- Settings Modal ---
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeModalBtn = document.getElementById('close-modal');
        settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
        closeModalBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
        window.addEventListener('click', e => { if (e.target == settingsModal) settingsModal.classList.add('hidden'); });
        const setCssVar = (name, value) => document.documentElement.style.setProperty(name, value);
        function darkenColor(hex, percent) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) hex = hex.split('').map(char => char + char).join('');
            const num = parseInt(hex, 16), amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt, G = (num >> 8 & 0x00FF) - amt, B = (num & 0x0000FF) - amt;
            return `#${(0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1)}`;
        }
        document.getElementById('p1-color-picker').addEventListener('input', e => setCssVar('--p1-color', e.target.value));
        document.getElementById('p1-glow-color-picker').addEventListener('input', e => setCssVar('--p1-glow-color', e.target.value));
        document.getElementById('p1-glow-size-slider').addEventListener('input', e => setCssVar('--p1-glow-size', e.target.value + 'px'));
        document.getElementById('p2-color-picker').addEventListener('input', e => setCssVar('--p2-color', e.target.value));
        document.getElementById('p2-glow-color-picker').addEventListener('input', e => setCssVar('--p2-glow-color', e.target.value));
        document.getElementById('p2-glow-size-slider').addEventListener('input', e => setCssVar('--p2-glow-size', e.target.value + 'px'));
        document.getElementById('board-bg-picker').addEventListener('input', e => setCssVar('--board-bg', e.target.value));
        document.getElementById('cell-bg-picker').addEventListener('input', e => {
            const newColor = e.target.value;
            setCssVar('--cell-bg', newColor);
            setCssVar('--cell-hover-bg', darkenColor(newColor, 10));
        });
        
        // --- App Initialization ---
        initializeAppLogic();

    </script>
</body>
</html>
